<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project Mindmap - Visual Database</title>
    <link
        href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700;900&family=Inter:wght@400;600;700&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --cosmic-dark: #0a0e27;
            --cosmic-deep: #1a1d3a;
            --neon-cyan: #00f0ff;
            --neon-magenta: #ff00e5;
            --neon-yellow: #ffd500;
            --neon-green: #00ff88;
            --neon-orange: #ff6b35;
            --neon-purple: #9d4edd;
            --neon-pink: #ff006e;
            --neon-blue: #4361ee;
            --neon-lime: #b5ff37;
            --neon-red: #ff1744;
            --star-white: #ffffff;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1d3a 100%);
            overflow: hidden;
            position: relative;
            height: 100vh;
            color: var(--star-white);
        }

        body::before {
            content: '';
            position: fixed;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            background-image:
                radial-gradient(circle at 20% 30%, rgba(0, 240, 255, 0.03) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(255, 0, 229, 0.03) 0%, transparent 50%),
                radial-gradient(circle at 50% 50%, rgba(255, 213, 0, 0.02) 0%, transparent 50%);
            animation: subtle-glow 10s ease-in-out infinite;
            z-index: -1;
        }

        @keyframes subtle-glow {

            0%,
            100% {
                opacity: 0.5;
            }

            50% {
                opacity: 0.8;
            }
        }

        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            padding: 24px 40px;
            background: rgba(10, 14, 39, 0.7);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid rgba(0, 240, 255, 0.2);
            z-index: 1000;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 30px;
        }

        h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.8rem;
            font-weight: 900;
            background: linear-gradient(135deg, var(--neon-cyan), var(--neon-magenta));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-transform: uppercase;
            letter-spacing: 0.15rem;
        }

        .nav-links {
            display: flex;
            gap: 12px;
        }

        .nav-link {
            padding: 8px 16px;
            background: rgba(0, 240, 255, 0.1);
            border: 1px solid rgba(0, 240, 255, 0.3);
            border-radius: 8px;
            color: var(--neon-cyan);
            text-decoration: none;
            font-size: 0.85rem;
            font-weight: 600;
            transition: all 0.2s ease;
            font-family: 'Inter', sans-serif;
        }

        .nav-link:hover {
            background: rgba(0, 240, 255, 0.2);
            border-color: var(--neon-cyan);
            transform: translateY(-1px);
        }

        .controls {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .line-style-selector {
            display: flex;
            gap: 8px;
            padding: 6px 12px;
            background: rgba(0, 240, 255, 0.1);
            border: 1px solid rgba(0, 240, 255, 0.3);
            border-radius: 8px;
            backdrop-filter: blur(10px);
        }

        .line-style-btn {
            padding: 6px 14px;
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: 'Inter', sans-serif;
        }

        .line-style-btn:hover {
            background: rgba(255, 255, 255, 0.05);
            color: var(--star-white);
        }

        .line-style-btn.active {
            background: rgba(0, 240, 255, 0.2);
            border-color: var(--neon-cyan);
            color: var(--neon-cyan);
        }

        .btn {
            padding: 10px 20px;
            background: rgba(0, 240, 255, 0.1);
            border: 1px solid rgba(0, 240, 255, 0.3);
            border-radius: 8px;
            color: var(--neon-cyan);
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: 'Inter', sans-serif;
            backdrop-filter: blur(10px);
        }

        .btn:hover {
            background: rgba(0, 240, 255, 0.2);
            border-color: var(--neon-cyan);
            transform: translateY(-1px);
        }

        .btn:active {
            transform: translateY(0);
        }

        .canvas {
            position: fixed;
            top: 80px;
            left: 0;
            right: 0;
            bottom: 0;
            overflow: auto;
        }

        .canvas-inner {
            position: relative;
            min-width: 3000px;
            min-height: 2000px;
            width: 100%;
            height: 100%;
        }

        #connector-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .node {
            position: absolute;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            padding: 14px 24px;
            background: rgba(26, 29, 58, 0.8);
            border: 2px solid;
            border-radius: 12px;
            color: var(--star-white);
            font-size: 1rem;
            font-weight: 600;
            cursor: grab;
            user-select: none;
            z-index: 10;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
            backdrop-filter: blur(10px);
            will-change: transform;
        }

        .node:active {
            cursor: grabbing;
        }

        .node:hover {
            transform: translateY(-2px);
            z-index: 100;
            justify-content: flex-start;
        }

        .node.dragging {
            opacity: 0.9;
            z-index: 1000;
            cursor: grabbing !important;
            transform: scale(1.03);
        }

        .node.connecting {
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }
        }

        .node-text {
            flex: 1;
            outline: none;
            min-width: 80px;
            padding: 2px;
            border-radius: 4px;
            transition: background 0.2s ease;
            text-align: center;
        }

        .node:hover .node-text {
            text-align: left;
        }

        .node-text:focus {
            background: rgba(255, 255, 255, 0.05);
        }

        .node-controls {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .mode-indicator {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 28px;
            background: rgba(26, 29, 58, 0.9);
            border: 1px solid var(--neon-yellow);
            border-radius: 20px;
            color: var(--neon-yellow);
            font-weight: 600;
            font-size: 0.9rem;
            z-index: 1000;
            display: none;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 20px rgba(255, 213, 0, 0.3);
        }

        .mode-indicator.active {
            display: block;
            animation: slide-up 0.2s ease;
        }

        @keyframes slide-up {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }

        .node.level-0 {
            border-color: var(--neon-cyan);
            box-shadow: 0 4px 20px rgba(0, 240, 255, 0.25);
        }

        .node.level-0:hover {
            box-shadow: 0 6px 30px rgba(0, 240, 255, 0.4);
        }

        .node.level-1 {
            border-color: var(--neon-magenta);
            box-shadow: 0 4px 20px rgba(255, 0, 229, 0.25);
        }

        .node.level-1:hover {
            box-shadow: 0 6px 30px rgba(255, 0, 229, 0.4);
        }

        .node.level-2 {
            border-color: var(--neon-yellow);
            box-shadow: 0 4px 20px rgba(255, 213, 0, 0.25);
        }

        .node.level-2:hover {
            box-shadow: 0 6px 30px rgba(255, 213, 0, 0.4);
        }

        .node.level-3 {
            border-color: var(--neon-green);
            box-shadow: 0 4px 20px rgba(0, 255, 136, 0.25);
        }

        .node.level-3:hover {
            box-shadow: 0 6px 30px rgba(0, 255, 136, 0.4);
        }

        .connection-line {
            stroke-width: 2;
            fill: none;
            opacity: 0.7;
            transition: opacity 0.2s ease;
        }

        .connection-line:hover {
            opacity: 1;
        }

        .status-indicator {
            position: fixed;
            top: 90px;
            right: 40px;
            padding: 8px 16px;
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 8px;
            color: var(--neon-green);
            font-size: 0.85rem;
            font-weight: 600;
            z-index: 1000;
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--neon-green);
            animation: blink 2s ease-in-out infinite;
        }

        @keyframes blink {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.3;
            }
        }

        .canvas::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        .canvas::-webkit-scrollbar-track {
            background: rgba(10, 14, 39, 0.5);
        }

        .canvas::-webkit-scrollbar-thumb {
            background: rgba(0, 240, 255, 0.3);
            border-radius: 4px;
        }

        .canvas::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 240, 255, 0.5);
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.3rem;
            }

            .header {
                padding: 20px;
                flex-direction: column;
                gap: 15px;
            }

            .header-left {
                flex-direction: column;
                gap: 15px;
                width: 100%;
            }

            .nav-links {
                width: 100%;
                justify-content: center;
            }

            .controls {
                flex-wrap: wrap;
                justify-content: center;
            }

            .btn {
                padding: 8px 16px;
                font-size: 0.85rem;
            }

            .node {
                padding: 12px 18px;
                font-size: 0.9rem;
            }
        }
    </style>
</head>

<body>
    <div class="header">
        <div class="header-left">
            <h1>PROJECT MINDMAP</h1>
            <div class="nav-links">
                <a href="/" class="nav-link">ðŸ‘¥ Team Dashboard</a>
                <a href="/onboarding" class="nav-link">ðŸš€ Onboarding</a>
            </div>
        </div>
        <div class="controls">
            <div class="line-style-selector">
                <button class="line-style-btn active" data-style="curved">Curved</button>
                <button class="line-style-btn" data-style="straight">Straight</button>
                <button class="line-style-btn" data-style="step">Step</button>
            </div>
            <input type="text" id="mindmap-search" placeholder="Search nodes..."
                style="padding: 8px 16px; background: rgba(0, 240, 255, 0.1); border: 1px solid rgba(0, 240, 255, 0.3); border-radius: 8px; color: var(--star-white); font-size: 0.85rem; font-family: 'Inter', sans-serif;">
            <select id="mindmap-status-filter"
                style="padding: 8px 16px; background: rgba(0, 240, 255, 0.1); border: 1px solid rgba(0, 240, 255, 0.3); border-radius: 8px; color: var(--star-white); font-size: 0.85rem; font-family: 'Inter', sans-serif;">
                <option value="all">All Projects</option>
                <option value="ongoing">Ongoing</option>
                <option value="completed">Completed</option>
                <option value="archived">Archived</option>
            </select>
            <button class="btn" id="add-node-btn">+ Add Node</button>
            <button class="btn" id="connect-mode-btn">ðŸ”— Connect</button>
            <button class="btn" id="sync-btn">ðŸ”„ Sync from Team Data</button>
            <button class="btn" id="organize-btn">âœ¨ Auto Organize</button>
        </div>
    </div>

    <div class="status-indicator">
        <div class="status-dot"></div>
        <span id="status-text">Connected to Database</span>
    </div>

    <div class="canvas" id="canvas">
        <div class="canvas-inner" id="canvas-inner">
            <svg id="connector-svg"></svg>
        </div>
    </div>

    <script>
        const API_BASE = '/api';

        async function apiCall(endpoint, options = {}) {
            try {
                const response = await fetch(`${API_BASE}${endpoint}`, {
                    headers: {
                        'Content-Type': 'application/json',
                        ...options.headers
                    },
                    ...options
                });

                if (!response.ok) {
                    throw new Error(`API Error: ${response.statusText}`);
                }

                return await response.json();
            } catch (error) {
                console.error('API call failed:', error);
                updateStatus('Error: Check console', true);
                throw error;
            }
        }

        async function loadNodesFromDB() {
            return await apiCall('/nodes');
        }

        async function saveNodeToDB(node) {
            return await apiCall('/nodes', {
                method: 'POST',
                body: JSON.stringify(node)
            });
        }

        async function loadConnectionsFromDB() {
            return await apiCall('/connections');
        }

        async function saveConnectionToDB(connection) {
            return await apiCall('/connections', {
                method: 'POST',
                body: JSON.stringify(connection)
            });
        }

        async function deleteNodeFromDB(nodeId) {
            return await apiCall(`/nodes/${nodeId}`, { method: 'DELETE' });
        }

        async function deleteConnectionFromDB(from, to) {
            return await apiCall('/connections/by-nodes', {
                method: 'DELETE',
                body: JSON.stringify({ from, to })
            });
        }

        async function syncFromTeamData() {
            return await apiCall('/sync-mindmap', { method: 'POST' });
        }

        async function initializeDatabase() {
            return await apiCall('/init-db', { method: 'POST' });
        }

        function updateStatus(text, isError = false) {
            const statusText = document.getElementById('status-text');
            statusText.textContent = text;
            if (isError) {
                statusText.style.color = 'var(--neon-magenta)';
            } else {
                statusText.style.color = 'var(--neon-green)';
            }
        }

        const canvas = document.getElementById('canvas');
        const canvasInner = document.getElementById('canvas-inner');
        const svg = document.getElementById('connector-svg');

        let nodes = [];
        let connections = [];
        let draggedNode = null;
        let dragOffset = { x: 0, y: 0 };
        let lineStyle = 'curved';
        let connectMode = false;
        let firstConnectNode = null;
        let searchQuery = '';
        let statusFilter = 'all';

        const lineColors = {
            0: 'rgba(0, 240, 255, 0.7)',
            1: 'rgba(255, 0, 229, 0.7)',
            2: 'rgba(255, 213, 0, 0.7)',
            3: 'rgba(0, 255, 136, 0.7)',
        };

        const createNodeElement = (node) => {
            const div = document.createElement('div');
            div.className = `node level-${node.level}`;
            div.dataset.id = node.id;
            div.style.left = `${node.x}px`;
            div.style.top = `${node.y}px`;

            div.innerHTML = `
                <span class="node-text" contenteditable="true">${node.text}</span>
                <div class="node-controls" style="display: flex; gap: 6px; opacity: 0; transition: opacity 0.2s;">
                    <button class="icon-btn connect-btn" title="Connect" style="width: 24px; height: 24px; border-radius: 50%; border: 1.5px solid var(--neon-yellow); background: rgba(10, 14, 39, 0.6); color: var(--neon-yellow); cursor: pointer;">âš¡</button>
                    <button class="icon-btn delete-btn" title="Delete" style="width: 24px; height: 24px; border-radius: 50%; border: 1.5px solid var(--neon-magenta); background: rgba(10, 14, 39, 0.6); color: var(--neon-magenta); cursor: pointer;">Ã—</button>
                </div>
            `;

            const textSpan = div.querySelector('.node-text');

            // Show controls on hover
            div.addEventListener('mouseenter', () => {
                div.querySelector('.node-controls').style.opacity = '1';
            });
            div.addEventListener('mouseleave', () => {
                div.querySelector('.node-controls').style.opacity = '0';
            });

            textSpan.addEventListener('mousedown', (e) => {
                e.stopPropagation();
            });

            textSpan.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    textSpan.blur();
                }
            });

            textSpan.addEventListener('blur', async () => {
                node.text = textSpan.textContent;
                await saveNodeToDB(node);
                updateStatus('Saved!');
                setTimeout(() => updateStatus('Connected to Database'), 2000);
                requestAnimationFrame(() => drawConnections());
            });

            div.addEventListener('mousedown', (e) => {
                if (e.target.closest('.icon-btn') || e.target === textSpan) {
                    return;
                }

                draggedNode = node;
                const rect = div.getBoundingClientRect();

                dragOffset.x = e.clientX - rect.left;
                dragOffset.y = e.clientY - rect.top;

                div.classList.add('dragging');
                e.preventDefault();
            });

            // Connect button
            div.querySelector('.connect-btn').addEventListener('click', async (e) => {
                e.stopPropagation();
                if (!connectMode) {
                    connectMode = true;
                    firstConnectNode = node;
                    div.classList.add('connecting');
                    document.getElementById('mode-indicator').classList.add('active');
                } else {
                    if (firstConnectNode && firstConnectNode.id !== node.id) {
                        const exists = connections.some(c =>
                            (c.from === firstConnectNode.id && c.to === node.id) ||
                            (c.from === node.id && c.to === firstConnectNode.id)
                        );
                        if (!exists) {
                            const connection = await saveConnectionToDB({
                                from: firstConnectNode.id,
                                to: node.id
                            });
                            connections.push(connection);
                            requestAnimationFrame(() => drawConnections());
                            updateStatus('Connected!');
                            setTimeout(() => updateStatus('Connected to Database'), 2000);
                        }
                    }
                    document.querySelector('.connecting')?.classList.remove('connecting');
                    connectMode = false;
                    firstConnectNode = null;
                    document.getElementById('mode-indicator').classList.remove('active');
                }
            });

            // Delete button
            div.querySelector('.delete-btn').addEventListener('click', async (e) => {
                e.stopPropagation();
                if (confirm('Delete this node and its connections?')) {
                    await deleteNodeFromDB(node.id);
                    nodes = nodes.filter(n => n.id !== node.id);

                    const connectionsToDelete = connections.filter(c => c.from === node.id || c.to === node.id);
                    for (const conn of connectionsToDelete) {
                        await deleteConnectionFromDB(conn.from, conn.to);
                    }
                    connections = connections.filter(c => c.from !== node.id && c.to !== node.id);

                    div.remove();
                    requestAnimationFrame(() => drawConnections());
                    updateStatus('Deleted!');
                    setTimeout(() => updateStatus('Connected to Database'), 2000);
                }
            });

            return div;
        };

        const drawConnections = () => {
            svg.innerHTML = '';

            connections.forEach(conn => {
                const fromNode = nodes.find(n => n.id === conn.from);
                const toNode = nodes.find(n => n.id === conn.to);

                if (fromNode && toNode) {
                    const fromEl = document.querySelector(`[data-id="${fromNode.id}"]`);
                    const toEl = document.querySelector(`[data-id="${toNode.id}"]`);

                    if (fromEl && toEl) {
                        const fromRect = fromEl.getBoundingClientRect();
                        const toRect = toEl.getBoundingClientRect();
                        const canvasRect = canvasInner.getBoundingClientRect();

                        const fromCenterX = fromRect.left + fromRect.width / 2 - canvasRect.left;
                        const fromCenterY = fromRect.top + fromRect.height / 2 - canvasRect.top;
                        const toCenterX = toRect.left + toRect.width / 2 - canvasRect.left;
                        const toCenterY = toRect.top + toRect.height / 2 - canvasRect.top;

                        const dx = toCenterX - fromCenterX;
                        const dy = toCenterY - fromCenterY;

                        let x1, y1, x2, y2;

                        if (Math.abs(dx) > Math.abs(dy)) {
                            if (dx > 0) {
                                x1 = fromRect.right - canvasRect.left;
                                y1 = fromCenterY;
                            } else {
                                x1 = fromRect.left - canvasRect.left;
                                y1 = fromCenterY;
                            }
                        } else {
                            if (dy > 0) {
                                x1 = fromCenterX;
                                y1 = fromRect.bottom - canvasRect.top;
                            } else {
                                x1 = fromCenterX;
                                y1 = fromRect.top - canvasRect.top;
                            }
                        }

                        if (Math.abs(dx) > Math.abs(dy)) {
                            if (dx > 0) {
                                x2 = toRect.left - canvasRect.left;
                                y2 = toCenterY;
                            } else {
                                x2 = toRect.right - canvasRect.left;
                                y2 = toCenterY;
                            }
                        } else {
                            if (dy > 0) {
                                x2 = toCenterX;
                                y2 = toRect.top - canvasRect.top;
                            } else {
                                x2 = toCenterX;
                                y2 = toRect.bottom - canvasRect.top;
                            }
                        }

                        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        let d;

                        const isNearlyHorizontal = Math.abs(dy) < 20 && Math.abs(dx) > 50;
                        const isNearlyVertical = Math.abs(dx) < 20 && Math.abs(dy) > 50;
                        const isNearlyStraight = isNearlyHorizontal || isNearlyVertical;

                        if (lineStyle === 'curved' && !isNearlyStraight) {
                            if (Math.abs(dx) > Math.abs(dy)) {
                                const offsetX = Math.abs(dx) * 0.3;
                                d = `M ${x1} ${y1} C ${x1 + (dx > 0 ? offsetX : -offsetX)} ${y1}, ${x2 - (dx > 0 ? offsetX : -offsetX)} ${y2}, ${x2} ${y2}`;
                            } else {
                                const offsetY = Math.abs(dy) * 0.3;
                                d = `M ${x1} ${y1} C ${x1} ${y1 + (dy > 0 ? offsetY : -offsetY)}, ${x2} ${y2 - (dy > 0 ? offsetY : -offsetY)}, ${x2} ${y2}`;
                            }
                        } else if (lineStyle === 'straight' || isNearlyStraight) {
                            d = `M ${x1} ${y1} L ${x2} ${y2}`;
                        } else if (lineStyle === 'step') {
                            if (Math.abs(dx) > Math.abs(dy)) {
                                const midX = (x1 + x2) / 2;
                                d = `M ${x1} ${y1} L ${midX} ${y1} L ${midX} ${y2} L ${x2} ${y2}`;
                            } else {
                                const midY = (y1 + y2) / 2;
                                d = `M ${x1} ${y1} L ${x1} ${midY} L ${x2} ${midY} L ${x2} ${y2}`;
                            }
                        }

                        path.setAttribute('d', d);
                        path.setAttribute('class', 'connection-line');
                        path.setAttribute('stroke', lineColors[fromNode.level] || lineColors[0]);

                        svg.appendChild(path);
                    }
                }
            });
        };

        let rafId = null;
        document.addEventListener('mousemove', (e) => {
            if (draggedNode) {
                if (rafId) return;

                rafId = requestAnimationFrame(() => {
                    const canvasRect = canvasInner.getBoundingClientRect();
                    const x = e.clientX - canvasRect.left - dragOffset.x;
                    const y = e.clientY - canvasRect.top - dragOffset.y;

                    draggedNode.x = Math.max(0, x);
                    draggedNode.y = Math.max(0, y);

                    const elem = document.querySelector(`[data-id="${draggedNode.id}"]`);
                    elem.style.left = `${draggedNode.x}px`;
                    elem.style.top = `${draggedNode.y}px`;

                    drawConnections();
                    rafId = null;
                });
            }
        });

        document.addEventListener('mouseup', async () => {
            if (draggedNode) {
                const elem = document.querySelector(`[data-id="${draggedNode.id}"]`);
                elem.classList.remove('dragging');
                await saveNodeToDB(draggedNode);
                updateStatus('Position saved!');
                setTimeout(() => updateStatus('Connected to Database'), 2000);
                draggedNode = null;
            }
        });

        document.querySelectorAll('.line-style-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.line-style-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                lineStyle = btn.dataset.style;
                requestAnimationFrame(() => drawConnections());
            });
        });

        document.getElementById('sync-btn').addEventListener('click', async () => {
            updateStatus('Syncing from team data...');
            try {
                await syncFromTeamData();
                await initializeApp();
                updateStatus('Synced successfully!');
                setTimeout(() => updateStatus('Connected to Database'), 2000);
            } catch (error) {
                updateStatus('Sync failed', true);
            }
        });

        document.getElementById('organize-btn').addEventListener('click', async () => {
            const rootNodes = nodes.filter(node =>
                !connections.some(conn => conn.to === node.id)
            );

            let currentY = 150;

            rootNodes.forEach(rootNode => {
                const tree = buildTree(rootNode.id);
                const treeHeight = layoutTree(tree, 250, currentY, 0);
                currentY += treeHeight + 100;
            });

            nodes.forEach(node => {
                const elem = document.querySelector(`[data-id="${node.id}"]`);
                if (elem) {
                    elem.style.left = `${node.x}px`;
                    elem.style.top = `${node.y}px`;
                }
            });

            requestAnimationFrame(() => {
                nodes.forEach(node => {
                    const elem = document.querySelector(`[data-id="${node.id}"]`);
                    if (elem) {
                        elem.style.transition = 'left 0.5s ease, top 0.5s ease';
                    }
                });

                const startTime = performance.now();
                const animationDuration = 500;

                const animateConnections = (currentTime) => {
                    drawConnections();

                    if (currentTime - startTime < animationDuration) {
                        requestAnimationFrame(animateConnections);
                    } else {
                        nodes.forEach(node => {
                            const elem = document.querySelector(`[data-id="${node.id}"]`);
                            if (elem) {
                                elem.style.transition = '';
                            }
                        });
                    }
                };

                requestAnimationFrame(animateConnections);
            });

            for (const node of nodes) {
                await saveNodeToDB(node);
            }
            updateStatus('Layout saved!');
            setTimeout(() => updateStatus('Connected to Database'), 2000);
        });

        function buildTree(nodeId, visited = new Set()) {
            if (visited.has(nodeId)) return null;
            visited.add(nodeId);

            const node = nodes.find(n => n.id === nodeId);
            if (!node) return null;

            const children = connections
                .filter(conn => conn.from === nodeId)
                .map(conn => buildTree(conn.to, visited))
                .filter(child => child !== null);

            return { node, children };
        }

        function layoutTree(tree, x, y, depth) {
            if (!tree) return 0;

            const horizontalSpacing = 500;
            const verticalSpacing = 100;

            tree.node.x = x;
            tree.node.y = y;

            if (tree.children.length === 0) {
                return verticalSpacing;
            }

            let totalHeight = 0;
            const childHeights = tree.children.map(child => {
                const height = calculateTreeHeight(child, verticalSpacing);
                totalHeight += height;
                return height;
            });

            const childrenStartY = y - (totalHeight - verticalSpacing) / 2;

            let currentChildY = childrenStartY;
            tree.children.forEach((child, index) => {
                const childHeight = layoutTree(
                    child,
                    x + horizontalSpacing,
                    currentChildY + childHeights[index] / 2,
                    depth + 1
                );
                currentChildY += childHeights[index];
            });

            return totalHeight;
        }

        function calculateTreeHeight(tree, spacing) {
            if (!tree || tree.children.length === 0) {
                return spacing;
            }

            const childrenHeight = tree.children.reduce((sum, child) => {
                return sum + calculateTreeHeight(child, spacing);
            }, 0);

            return Math.max(spacing, childrenHeight);
        }

        async function initializeApp() {
            try {
                updateStatus('Loading...');

                await initializeDatabase();

                const loadedNodes = await loadNodesFromDB();
                const loadedConnections = await loadConnectionsFromDB();

                nodes = loadedNodes;
                connections = loadedConnections;

                renderNodes();

                setTimeout(() => {
                    drawConnections();
                    updateStatus('Connected to Database');
                }, 50);

            } catch (error) {
                console.error('Failed to initialize app:', error);
                updateStatus('Connection failed', true);
            }
        }

        function renderNodes() {
            canvasInner.querySelectorAll('.node').forEach(el => el.remove());

            const filteredNodes = nodes.filter(node => {
                const matchesSearch = node.text.toLowerCase().includes(searchQuery.toLowerCase());
                // Filter by project status if node is a project
                if (statusFilter !== 'all' && node.entityType === 'project') {
                    // Would need to fetch project status - for now just show all
                    return matchesSearch;
                }
                return matchesSearch;
            });

            filteredNodes.forEach(node => {
                const elem = createNodeElement(node);
                canvasInner.appendChild(elem);
            });
        }

        document.getElementById('add-node-btn').addEventListener('click', async () => {
            const newNode = await saveNodeToDB({
                x: 300 + Math.random() * 200,
                y: 300 + Math.random() * 200,
                text: 'New Node',
                level: 0,
                entityType: 'custom',
                entityId: `custom_${Date.now()}`
            });

            nodes.push(newNode);
            const elem = createNodeElement(newNode);
            canvasInner.appendChild(elem);
            updateStatus('Node created!');
            setTimeout(() => updateStatus('Connected to Database'), 2000);

            setTimeout(() => {
                const textSpan = elem.querySelector('.node-text');
                textSpan.focus();
                document.execCommand('selectAll', false, null);
            }, 100);
        });

        document.getElementById('connect-mode-btn').addEventListener('click', () => {
            connectMode = !connectMode;
            if (connectMode) {
                document.getElementById('mode-indicator').classList.add('active');
            } else {
                document.getElementById('mode-indicator').classList.remove('active');
                document.querySelector('.connecting')?.classList.remove('connecting');
                firstConnectNode = null;
            }
        });

        document.getElementById('mindmap-search').addEventListener('input', (e) => {
            searchQuery = e.target.value;
            renderNodes();
            setTimeout(() => drawConnections(), 50);
        });

        document.getElementById('mindmap-status-filter').addEventListener('change', (e) => {
            statusFilter = e.target.value;
            renderNodes();
            setTimeout(() => drawConnections(), 50);
        });

        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                requestAnimationFrame(() => drawConnections());
            }, 100);
        });

        initializeApp();
    </script>
</body>

</html>