<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project Tracker</title>
    <link
        href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700;900&family=Inter:wght@400;600;700&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --cosmic-dark: #0a0e27;
            --cosmic-deep: #1a1d3a;
            --neon-cyan: #00f0ff;
            --neon-magenta: #ff00e5;
            --neon-yellow: #ffd500;
            --neon-green: #00ff88;
            --star-white: #ffffff;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1d3a 100%);
            overflow: hidden;
            position: relative;
            height: 100vh;
            color: var(--star-white);
        }

        /* Subtle animated background */
        body::before {
            content: '';
            position: fixed;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            background-image:
                radial-gradient(circle at 20% 30%, rgba(0, 240, 255, 0.03) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(255, 0, 229, 0.03) 0%, transparent 50%),
                radial-gradient(circle at 50% 50%, rgba(255, 213, 0, 0.02) 0%, transparent 50%);
            animation: subtle-glow 10s ease-in-out infinite;
            z-index: -1;
        }

        @keyframes subtle-glow {

            0%,
            100% {
                opacity: 0.5;
            }

            50% {
                opacity: 0.8;
            }
        }

        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            padding: 24px 40px;
            background: rgba(10, 14, 39, 0.7);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid rgba(0, 240, 255, 0.2);
            z-index: 1000;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.8rem;
            font-weight: 900;
            background: linear-gradient(135deg, var(--neon-cyan), var(--neon-magenta));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-transform: uppercase;
            letter-spacing: 0.15rem;
        }

        .controls {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .line-style-selector {
            display: flex;
            gap: 8px;
            padding: 6px 12px;
            background: rgba(0, 240, 255, 0.1);
            border: 1px solid rgba(0, 240, 255, 0.3);
            border-radius: 8px;
            backdrop-filter: blur(10px);
        }

        .line-style-btn {
            padding: 6px 14px;
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: 'Inter', sans-serif;
        }

        .line-style-btn:hover {
            background: rgba(255, 255, 255, 0.05);
            color: var(--star-white);
        }

        .line-style-btn.active {
            background: rgba(0, 240, 255, 0.2);
            border-color: var(--neon-cyan);
            color: var(--neon-cyan);
        }

        .btn {
            padding: 10px 20px;
            background: rgba(0, 240, 255, 0.1);
            border: 1px solid rgba(0, 240, 255, 0.3);
            border-radius: 8px;
            color: var(--neon-cyan);
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: 'Inter', sans-serif;
            backdrop-filter: blur(10px);
        }

        .btn:hover {
            background: rgba(0, 240, 255, 0.2);
            border-color: var(--neon-cyan);
            transform: translateY(-1px);
        }

        .btn:active {
            transform: translateY(0);
        }

        .canvas {
            position: fixed;
            top: 80px;
            left: 0;
            right: 0;
            bottom: 0;
            overflow: auto;
        }

        .canvas-inner {
            position: relative;
            min-width: 3000px;
            min-height: 2000px;
            width: 100%;
            height: 100%;
        }

        #connector-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .node {
            position: absolute;
            display: inline-flex;
            align-items: center;
            gap: 12px;
            padding: 14px 24px;
            background: rgba(26, 29, 58, 0.8);
            border: 2px solid;
            border-radius: 12px;
            color: var(--star-white);
            font-size: 1rem;
            font-weight: 600;
            cursor: grab;
            user-select: none;
            z-index: 10;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
            backdrop-filter: blur(10px);
            will-change: transform;
        }

        .node:active {
            cursor: grabbing;
        }

        .node:hover {
            transform: translateY(-2px);
            z-index: 100;
        }

        .node.dragging {
            opacity: 0.9;
            z-index: 1000;
            cursor: grabbing !important;
            transform: scale(1.03);
        }

        .node.connecting {
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }
        }

        .node-text {
            flex: 1;
            outline: none;
            min-width: 80px;
            padding: 2px;
            border-radius: 4px;
            transition: background 0.2s ease;
        }

        .node-text:focus {
            background: rgba(255, 255, 255, 0.05);
        }

        .node-controls {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .icon-btn {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 1.5px solid;
            background: rgba(10, 14, 39, 0.6);
            font-size: 0.85rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.15s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
            flex-shrink: 0;
        }

        .icon-btn:hover {
            transform: scale(1.15);
        }

        .icon-btn:active {
            transform: scale(0.95);
        }

        .add-btn {
            border-color: var(--neon-green);
            color: var(--neon-green);
        }

        .add-btn:hover {
            background: rgba(0, 255, 136, 0.2);
            box-shadow: 0 0 12px rgba(0, 255, 136, 0.4);
        }

        .connect-btn {
            border-color: var(--neon-yellow);
            color: var(--neon-yellow);
        }

        .connect-btn:hover {
            background: rgba(255, 213, 0, 0.2);
            box-shadow: 0 0 12px rgba(255, 213, 0, 0.4);
        }

        .delete-btn {
            border-color: var(--neon-magenta);
            color: var(--neon-magenta);
        }

        .delete-btn:hover {
            background: rgba(255, 0, 229, 0.2);
            box-shadow: 0 0 12px rgba(255, 0, 229, 0.4);
        }

        /* Level colors with smooth glow */
        .node.level-0 {
            border-color: var(--neon-cyan);
            box-shadow: 0 4px 20px rgba(0, 240, 255, 0.25);
        }

        .node.level-0:hover {
            box-shadow: 0 6px 30px rgba(0, 240, 255, 0.4);
        }

        .node.level-1 {
            border-color: var(--neon-magenta);
            box-shadow: 0 4px 20px rgba(255, 0, 229, 0.25);
        }

        .node.level-1:hover {
            box-shadow: 0 6px 30px rgba(255, 0, 229, 0.4);
        }

        .node.level-2 {
            border-color: var(--neon-yellow);
            box-shadow: 0 4px 20px rgba(255, 213, 0, 0.25);
        }

        .node.level-2:hover {
            box-shadow: 0 6px 30px rgba(255, 213, 0, 0.4);
        }

        .node.level-3 {
            border-color: var(--neon-green);
            box-shadow: 0 4px 20px rgba(0, 255, 136, 0.25);
        }

        .node.level-3:hover {
            box-shadow: 0 6px 30px rgba(0, 255, 136, 0.4);
        }

        /* Smooth connection lines */
        .connection-line {
            stroke-width: 2;
            fill: none;
            opacity: 0.7;
            transition: opacity 0.2s ease;
        }

        .connection-line:hover {
            opacity: 1;
        }

        .mode-indicator {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 28px;
            background: rgba(26, 29, 58, 0.9);
            border: 1px solid var(--neon-yellow);
            border-radius: 20px;
            color: var(--neon-yellow);
            font-weight: 600;
            font-size: 0.9rem;
            z-index: 1000;
            display: none;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 20px rgba(255, 213, 0, 0.3);
        }

        .mode-indicator.active {
            display: block;
            animation: slide-up 0.2s ease;
        }

        @keyframes slide-up {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }

        /* Scrollbar styling */
        .canvas::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        .canvas::-webkit-scrollbar-track {
            background: rgba(10, 14, 39, 0.5);
        }

        .canvas::-webkit-scrollbar-thumb {
            background: rgba(0, 240, 255, 0.3);
            border-radius: 4px;
        }

        .canvas::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 240, 255, 0.5);
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.3rem;
            }

            .header {
                padding: 20px;
            }

            .btn {
                padding: 8px 16px;
                font-size: 0.85rem;
            }

            .node {
                padding: 12px 18px;
                font-size: 0.9rem;
            }
        }
    </style>
</head>

<body>
    <div class="header">
        <h1>PROJECT COSMOS</h1>
        <div class="controls">
            <div class="line-style-selector">
                <button class="line-style-btn active" data-style="curved">Curved</button>
                <button class="line-style-btn" data-style="straight">Straight</button>
                <button class="line-style-btn" data-style="step">Step</button>
            </div>
            <button class="btn" id="add-node-btn">+ Add Node</button>
            <button class="btn" id="connect-mode-btn">ðŸ”— Connect</button>
        </div>
    </div>

    <div class="canvas" id="canvas">
        <div class="canvas-inner" id="canvas-inner">
            <svg id="connector-svg"></svg>
        </div>
    </div>

    <div class="mode-indicator" id="mode-indicator">
        Click a node, then click another to connect
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const canvasInner = document.getElementById('canvas-inner');
        const svg = document.getElementById('connector-svg');
        const modeIndicator = document.getElementById('mode-indicator');

        let nodes = [];
        let connections = [];
        let nodeIdCounter = 0;
        let draggedNode = null;
        let dragOffset = { x: 0, y: 0 };
        let connectMode = false;
        let firstConnectNode = null;
        let lineStyle = 'curved'; // curved, straight, or step

        // Color palette for connection lines
        const lineColors = {
            0: 'rgba(0, 240, 255, 0.7)',
            1: 'rgba(255, 0, 229, 0.7)',
            2: 'rgba(255, 213, 0, 0.7)',
            3: 'rgba(0, 255, 136, 0.7)'
        };

        // Initialize with hierarchical layout - well-spaced
        const initNodes = [
            { id: 0, x: 150, y: 250, text: 'Project: Ares IV Colony', level: 0 },
            { id: 1, x: 550, y: 180, text: 'PM: Dr. Eva Rostova', level: 1 },
            { id: 2, x: 950, y: 100, text: 'Senior Developers', level: 2 },
            { id: 3, x: 950, y: 260, text: 'Junior Developers', level: 2 },
            { id: 4, x: 1400, y: 50, text: 'Mika Petrova', level: 3 },
            { id: 5, x: 1400, y: 120, text: 'Dr. Aris Thorne', level: 3 },
            { id: 6, x: 1400, y: 220, text: 'Leo Kwan', level: 3 },
            { id: 7, x: 1400, y: 280, text: 'Ria Sharma', level: 3 },
            { id: 8, x: 1400, y: 340, text: 'Zane Al-Jamil', level: 3 },
            { id: 9, x: 150, y: 600, text: 'Project: Neptune Deep-Dive', level: 0 },
            { id: 10, x: 550, y: 600, text: 'PM: Jax Riley', level: 1 },
            { id: 11, x: 950, y: 540, text: 'Senior Developers', level: 2 },
            { id: 12, x: 950, y: 660, text: 'Junior Developers', level: 2 },
            { id: 13, x: 1400, y: 540, text: 'Kenji Tanaka', level: 3 },
            { id: 14, x: 1400, y: 640, text: 'Sora Kim', level: 3 },
            { id: 15, x: 1400, y: 700, text: "Finn O'Malley", level: 3 },
        ];

        const initConnections = [
            { from: 0, to: 1 },
            { from: 1, to: 2 },
            { from: 1, to: 3 },
            { from: 2, to: 4 },
            { from: 2, to: 5 },
            { from: 3, to: 6 },
            { from: 3, to: 7 },
            { from: 3, to: 8 },
            { from: 9, to: 10 },
            { from: 10, to: 11 },
            { from: 10, to: 12 },
            { from: 11, to: 13 },
            { from: 12, to: 14 },
            { from: 12, to: 15 },
        ];

        nodeIdCounter = initNodes.length;

        const createNodeElement = (node) => {
            const div = document.createElement('div');
            div.className = `node level-${node.level}`;
            div.dataset.id = node.id;
            div.style.left = `${node.x}px`;
            div.style.top = `${node.y}px`;

            div.innerHTML = `
                <span class="node-text" contenteditable="true">${node.text}</span>
                <div class="node-controls">
                    <button class="icon-btn add-btn" title="Add child">+</button>
                    <button class="icon-btn connect-btn" title="Connect">âš¡</button>
                    <button class="icon-btn delete-btn" title="Delete">Ã—</button>
                </div>
            `;

            const textSpan = div.querySelector('.node-text');

            textSpan.addEventListener('mousedown', (e) => {
                e.stopPropagation();
            });

            textSpan.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    textSpan.blur();
                }
            });

            textSpan.addEventListener('blur', () => {
                node.text = textSpan.textContent;
            });

            // Smooth drag functionality
            div.addEventListener('mousedown', (e) => {
                if (e.target.closest('.icon-btn') || e.target === textSpan) {
                    return;
                }

                draggedNode = node;
                const rect = div.getBoundingClientRect();

                dragOffset.x = e.clientX - rect.left;
                dragOffset.y = e.clientY - rect.top;

                div.classList.add('dragging');
                e.preventDefault();
            });

            // Add child button
            div.querySelector('.add-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                const newNode = {
                    id: nodeIdCounter++,
                    x: node.x + 350,
                    y: node.y + (Math.random() - 0.5) * 100,
                    text: 'New Node',
                    level: (node.level + 1) % 4
                };
                nodes.push(newNode);
                connections.push({ from: node.id, to: newNode.id });
                const elem = createNodeElement(newNode);
                canvasInner.appendChild(elem);
                requestAnimationFrame(() => drawConnections());

                setTimeout(() => {
                    const newTextSpan = elem.querySelector('.node-text');
                    newTextSpan.focus();
                    document.execCommand('selectAll', false, null);
                }, 100);
            });

            // Connect button
            div.querySelector('.connect-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                if (!connectMode) {
                    connectMode = true;
                    firstConnectNode = node;
                    div.classList.add('connecting');
                    modeIndicator.classList.add('active');
                } else {
                    if (firstConnectNode && firstConnectNode.id !== node.id) {
                        const exists = connections.some(c =>
                            (c.from === firstConnectNode.id && c.to === node.id) ||
                            (c.from === node.id && c.to === firstConnectNode.id)
                        );
                        if (!exists) {
                            connections.push({ from: firstConnectNode.id, to: node.id });
                            requestAnimationFrame(() => drawConnections());
                        }
                    }
                    document.querySelector('.connecting')?.classList.remove('connecting');
                    connectMode = false;
                    firstConnectNode = null;
                    modeIndicator.classList.remove('active');
                }
            });

            // Delete button
            div.querySelector('.delete-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                nodes = nodes.filter(n => n.id !== node.id);
                connections = connections.filter(c => c.from !== node.id && c.to !== node.id);
                div.remove();
                requestAnimationFrame(() => drawConnections());
            });

            return div;
        };

        const drawConnections = () => {
            svg.innerHTML = '';

            connections.forEach(conn => {
                const fromNode = nodes.find(n => n.id === conn.from);
                const toNode = nodes.find(n => n.id === conn.to);

                if (fromNode && toNode) {
                    const fromEl = document.querySelector(`[data-id="${fromNode.id}"]`);
                    const toEl = document.querySelector(`[data-id="${toNode.id}"]`);

                    if (fromEl && toEl) {
                        const fromRect = fromEl.getBoundingClientRect();
                        const toRect = toEl.getBoundingClientRect();
                        const canvasRect = canvasInner.getBoundingClientRect();

                        // Calculate center points
                        const fromCenterX = fromRect.left + fromRect.width / 2 - canvasRect.left;
                        const fromCenterY = fromRect.top + fromRect.height / 2 - canvasRect.top;
                        const toCenterX = toRect.left + toRect.width / 2 - canvasRect.left;
                        const toCenterY = toRect.top + toRect.height / 2 - canvasRect.top;

                        // Calculate angle between nodes
                        const dx = toCenterX - fromCenterX;
                        const dy = toCenterY - fromCenterY;
                        const angle = Math.atan2(dy, dx);

                        // Determine connection points based on relative positions
                        let x1, y1, x2, y2;

                        // From node connection point
                        if (Math.abs(dx) > Math.abs(dy)) {
                            // Horizontal connection dominant
                            if (dx > 0) {
                                // Connect from right side of fromNode
                                x1 = fromRect.right - canvasRect.left;
                                y1 = fromCenterY;
                            } else {
                                // Connect from left side of fromNode
                                x1 = fromRect.left - canvasRect.left;
                                y1 = fromCenterY;
                            }
                        } else {
                            // Vertical connection dominant
                            if (dy > 0) {
                                // Connect from bottom of fromNode
                                x1 = fromCenterX;
                                y1 = fromRect.bottom - canvasRect.top;
                            } else {
                                // Connect from top of fromNode
                                x1 = fromCenterX;
                                y1 = fromRect.top - canvasRect.top;
                            }
                        }

                        // To node connection point
                        if (Math.abs(dx) > Math.abs(dy)) {
                            // Horizontal connection dominant
                            if (dx > 0) {
                                // Connect to left side of toNode
                                x2 = toRect.left - canvasRect.left;
                                y2 = toCenterY;
                            } else {
                                // Connect to right side of toNode
                                x2 = toRect.right - canvasRect.left;
                                y2 = toCenterY;
                            }
                        } else {
                            // Vertical connection dominant
                            if (dy > 0) {
                                // Connect to top of toNode
                                x2 = toCenterX;
                                y2 = toRect.top - canvasRect.top;
                            } else {
                                // Connect to bottom of toNode
                                x2 = toCenterX;
                                y2 = toRect.bottom - canvasRect.top;
                            }
                        }

                        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        let d;

                        // Calculate if the connection is nearly straight
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        const isNearlyHorizontal = Math.abs(dy) < 20 && Math.abs(dx) > 50;
                        const isNearlyVertical = Math.abs(dx) < 20 && Math.abs(dy) > 50;
                        const isNearlyStraight = isNearlyHorizontal || isNearlyVertical;

                        if (lineStyle === 'curved' && !isNearlyStraight) {
                            const controlOffset = Math.min(distance * 0.25, 150);

                            if (Math.abs(dx) > Math.abs(dy)) {
                                // Horizontal curve - gentler
                                const offsetX = Math.abs(dx) * 0.3;
                                d = `M ${x1} ${y1} C ${x1 + (dx > 0 ? offsetX : -offsetX)} ${y1}, ${x2 - (dx > 0 ? offsetX : -offsetX)} ${y2}, ${x2} ${y2}`;
                            } else {
                                // Vertical curve - gentler
                                const offsetY = Math.abs(dy) * 0.3;
                                d = `M ${x1} ${y1} C ${x1} ${y1 + (dy > 0 ? offsetY : -offsetY)}, ${x2} ${y2 - (dy > 0 ? offsetY : -offsetY)}, ${x2} ${y2}`;
                            }
                        } else if (lineStyle === 'straight' || isNearlyStraight) {
                            d = `M ${x1} ${y1} L ${x2} ${y2}`;
                        } else if (lineStyle === 'step') {
                            if (Math.abs(dx) > Math.abs(dy)) {
                                // Horizontal-first step
                                const midX = (x1 + x2) / 2;
                                d = `M ${x1} ${y1} L ${midX} ${y1} L ${midX} ${y2} L ${x2} ${y2}`;
                            } else {
                                // Vertical-first step
                                const midY = (y1 + y2) / 2;
                                d = `M ${x1} ${y1} L ${x1} ${midY} L ${x2} ${midY} L ${x2} ${y2}`;
                            }
                        }

                        path.setAttribute('d', d);
                        path.setAttribute('class', 'connection-line');
                        path.setAttribute('stroke', lineColors[fromNode.level] || lineColors[0]);

                        svg.appendChild(path);
                    }
                }
            });
        };

        // Optimized mouse move with RAF
        let rafId = null;
        document.addEventListener('mousemove', (e) => {
            if (draggedNode) {
                if (rafId) return;

                rafId = requestAnimationFrame(() => {
                    const canvasRect = canvasInner.getBoundingClientRect();
                    const x = e.clientX - canvasRect.left - dragOffset.x;
                    const y = e.clientY - canvasRect.top - dragOffset.y;

                    draggedNode.x = Math.max(0, x);
                    draggedNode.y = Math.max(0, y);

                    const elem = document.querySelector(`[data-id="${draggedNode.id}"]`);
                    elem.style.left = `${draggedNode.x}px`;
                    elem.style.top = `${draggedNode.y}px`;

                    drawConnections();
                    rafId = null;
                });
            }
        });

        document.addEventListener('mouseup', () => {
            if (draggedNode) {
                const elem = document.querySelector(`[data-id="${draggedNode.id}"]`);
                elem.classList.remove('dragging');
                draggedNode = null;
            }
        });

        // Add node button
        document.getElementById('add-node-btn').addEventListener('click', () => {
            const newNode = {
                id: nodeIdCounter++,
                x: 300 + Math.random() * 200,
                y: 300 + Math.random() * 200,
                text: 'New Node',
                level: 0
            };
            nodes.push(newNode);
            const elem = createNodeElement(newNode);
            canvasInner.appendChild(elem);

            setTimeout(() => {
                const textSpan = elem.querySelector('.node-text');
                textSpan.focus();
                document.execCommand('selectAll', false, null);
            }, 100);
        });

        // Connect mode button
        document.getElementById('connect-mode-btn').addEventListener('click', () => {
            connectMode = !connectMode;
            if (connectMode) {
                modeIndicator.classList.add('active');
            } else {
                modeIndicator.classList.remove('active');
                document.querySelector('.connecting')?.classList.remove('connecting');
                firstConnectNode = null;
            }
        });

        // Line style selector
        document.querySelectorAll('.line-style-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.line-style-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                lineStyle = btn.dataset.style;
                requestAnimationFrame(() => drawConnections());
            });
        });

        // Initialize
        nodes = initNodes;
        connections = initConnections;
        initNodes.forEach(node => {
            const elem = createNodeElement(node);
            canvasInner.appendChild(elem);
        });

        setTimeout(() => {
            drawConnections();
        }, 50);

        // Smooth redraw on resize with debounce
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                requestAnimationFrame(() => drawConnections());
            }, 100);
        });
    </script>
</body>

</html>