<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project Tracker</title>
    <link
        href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700;900&family=Inter:wght@400;600;700&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --cosmic-dark: #0a0e27;
            --cosmic-deep: #1a1d3a;
            --neon-cyan: #00f0ff;
            --neon-magenta: #ff00e5;
            --neon-yellow: #ffd500;
            --neon-green: #00ff88;
            --star-white: #ffffff;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1d3a 100%);
            overflow: hidden;
            position: relative;
            height: 100vh;
            color: var(--star-white);
        }

        body::before {
            content: '';
            position: fixed;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            background-image:
                radial-gradient(circle at 20% 30%, rgba(0, 240, 255, 0.03) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(255, 0, 229, 0.03) 0%, transparent 50%),
                radial-gradient(circle at 50% 50%, rgba(255, 213, 0, 0.02) 0%, transparent 50%);
            animation: subtle-glow 10s ease-in-out infinite;
            z-index: -1;
        }

        @keyframes subtle-glow {

            0%,
            100% {
                opacity: 0.5;
            }

            50% {
                opacity: 0.8;
            }
        }

        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            padding: 24px 40px;
            background: rgba(10, 14, 39, 0.7);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid rgba(0, 240, 255, 0.2);
            z-index: 1000;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.8rem;
            font-weight: 900;
            background: linear-gradient(135deg, var(--neon-cyan), var(--neon-magenta));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-transform: uppercase;
            letter-spacing: 0.15rem;
        }

        .controls {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .line-style-selector {
            display: flex;
            gap: 8px;
            padding: 6px 12px;
            background: rgba(0, 240, 255, 0.1);
            border: 1px solid rgba(0, 240, 255, 0.3);
            border-radius: 8px;
            backdrop-filter: blur(10px);
        }

        .line-style-btn {
            padding: 6px 14px;
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: 'Inter', sans-serif;
        }

        .line-style-btn:hover {
            background: rgba(255, 255, 255, 0.05);
            color: var(--star-white);
        }

        .line-style-btn.active {
            background: rgba(0, 240, 255, 0.2);
            border-color: var(--neon-cyan);
            color: var(--neon-cyan);
        }

        .btn {
            padding: 10px 20px;
            background: rgba(0, 240, 255, 0.1);
            border: 1px solid rgba(0, 240, 255, 0.3);
            border-radius: 8px;
            color: var(--neon-cyan);
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: 'Inter', sans-serif;
            backdrop-filter: blur(10px);
        }

        .btn:hover {
            background: rgba(0, 240, 255, 0.2);
            border-color: var(--neon-cyan);
            transform: translateY(-1px);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn.danger {
            background: rgba(255, 0, 229, 0.1);
            border-color: rgba(255, 0, 229, 0.3);
            color: var(--neon-magenta);
        }

        .btn.danger:hover {
            background: rgba(255, 0, 229, 0.2);
            border-color: var(--neon-magenta);
        }

        .canvas {
            position: fixed;
            top: 80px;
            left: 0;
            right: 0;
            bottom: 0;
            overflow: auto;
        }

        .canvas-inner {
            position: relative;
            min-width: 3000px;
            min-height: 2000px;
            width: 100%;
            height: 100%;
        }

        #connector-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .node {
            position: absolute;
            display: inline-flex;
            align-items: center;
            gap: 12px;
            padding: 14px 24px;
            background: rgba(26, 29, 58, 0.8);
            border: 2px solid;
            border-radius: 12px;
            color: var(--star-white);
            font-size: 1rem;
            font-weight: 600;
            cursor: grab;
            user-select: none;
            z-index: 10;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
            backdrop-filter: blur(10px);
            will-change: transform;
        }

        .node:active {
            cursor: grabbing;
        }

        .node:hover {
            transform: translateY(-2px);
            z-index: 100;
        }

        .node.dragging {
            opacity: 0.9;
            z-index: 1000;
            cursor: grabbing !important;
            transform: scale(1.03);
        }

        .node.connecting {
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }
        }

        .node-text {
            flex: 1;
            outline: none;
            min-width: 80px;
            padding: 2px;
            border-radius: 4px;
            transition: background 0.2s ease;
        }

        .node-text:focus {
            background: rgba(255, 255, 255, 0.05);
        }

        .node-controls {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .icon-btn {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 1.5px solid;
            background: rgba(10, 14, 39, 0.6);
            font-size: 0.85rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.15s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
            flex-shrink: 0;
        }

        .icon-btn:hover {
            transform: scale(1.15);
        }

        .icon-btn:active {
            transform: scale(0.95);
        }

        .add-btn {
            border-color: var(--neon-green);
            color: var(--neon-green);
        }

        .add-btn:hover {
            background: rgba(0, 255, 136, 0.2);
            box-shadow: 0 0 12px rgba(0, 255, 136, 0.4);
        }

        .connect-btn {
            border-color: var(--neon-yellow);
            color: var(--neon-yellow);
        }

        .connect-btn:hover {
            background: rgba(255, 213, 0, 0.2);
            box-shadow: 0 0 12px rgba(255, 213, 0, 0.4);
        }

        .delete-btn {
            border-color: var(--neon-magenta);
            color: var(--neon-magenta);
        }

        .delete-btn:hover {
            background: rgba(255, 0, 229, 0.2);
            box-shadow: 0 0 12px rgba(255, 0, 229, 0.4);
        }

        .node.level-0 {
            border-color: var(--neon-cyan);
            box-shadow: 0 4px 20px rgba(0, 240, 255, 0.25);
        }

        .node.level-0:hover {
            box-shadow: 0 6px 30px rgba(0, 240, 255, 0.4);
        }

        .node.level-1 {
            border-color: var(--neon-magenta);
            box-shadow: 0 4px 20px rgba(255, 0, 229, 0.25);
        }

        .node.level-1:hover {
            box-shadow: 0 6px 30px rgba(255, 0, 229, 0.4);
        }

        .node.level-2 {
            border-color: var(--neon-yellow);
            box-shadow: 0 4px 20px rgba(255, 213, 0, 0.25);
        }

        .node.level-2:hover {
            box-shadow: 0 6px 30px rgba(255, 213, 0, 0.4);
        }

        .node.level-3 {
            border-color: var(--neon-green);
            box-shadow: 0 4px 20px rgba(0, 255, 136, 0.25);
        }

        .node.level-3:hover {
            box-shadow: 0 6px 30px rgba(0, 255, 136, 0.4);
        }

        .connection-line {
            stroke-width: 2;
            fill: none;
            opacity: 0.7;
            transition: opacity 0.2s ease;
        }

        .connection-line:hover {
            opacity: 1;
        }

        .mode-indicator {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 28px;
            background: rgba(26, 29, 58, 0.9);
            border: 1px solid var(--neon-yellow);
            border-radius: 20px;
            color: var(--neon-yellow);
            font-weight: 600;
            font-size: 0.9rem;
            z-index: 1000;
            display: none;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 20px rgba(255, 213, 0, 0.3);
        }

        .mode-indicator.active {
            display: block;
            animation: slide-up 0.2s ease;
        }

        @keyframes slide-up {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }

        .status-indicator {
            position: fixed;
            top: 90px;
            right: 40px;
            padding: 8px 16px;
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 8px;
            color: var(--neon-green);
            font-size: 0.85rem;
            font-weight: 600;
            z-index: 1000;
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--neon-green);
            animation: blink 2s ease-in-out infinite;
        }

        @keyframes blink {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.3;
            }
        }

        .canvas::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        .canvas::-webkit-scrollbar-track {
            background: rgba(10, 14, 39, 0.5);
        }

        .canvas::-webkit-scrollbar-thumb {
            background: rgba(0, 240, 255, 0.3);
            border-radius: 4px;
        }

        .canvas::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 240, 255, 0.5);
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.3rem;
            }

            .header {
                padding: 20px;
            }

            .btn {
                padding: 8px 16px;
                font-size: 0.85rem;
            }

            .node {
                padding: 12px 18px;
                font-size: 0.9rem;
            }
        }
    </style>
</head>

<body>
    <div class="header">
        <h1>PROJECT COSMOS</h1>
        <div class="controls">
            <div class="line-style-selector">
                <button class="line-style-btn active" data-style="curved">Curved</button>
                <button class="line-style-btn" data-style="straight">Straight</button>
                <button class="line-style-btn" data-style="step">Step</button>
            </div>
            <button class="btn" id="organize-btn">‚ú® Auto Organize</button>
            <button class="btn" id="add-node-btn">+ Add Node</button>
            <button class="btn" id="connect-mode-btn">üîó Connect</button>
            <button class="btn danger" id="clear-db-btn">üóëÔ∏è Clear All</button>
        </div>
    </div>

    <div class="status-indicator">
        <div class="status-dot"></div>
        <span>Auto-saving to database</span>
    </div>

    <div class="canvas" id="canvas">
        <div class="canvas-inner" id="canvas-inner">
            <svg id="connector-svg"></svg>
        </div>
    </div>

    <div class="mode-indicator" id="mode-indicator">
        Click a node, then click another to connect
    </div>

    <script>
        // ==================== DATABASE SETUP ====================
        let db;
        const DB_NAME = 'ProjectTrackerDB';
        const DB_VERSION = 1;

        function initDatabase() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);

                request.onerror = () => reject(request.error);
                request.onsuccess = () => {
                    db = request.result;
                    resolve(db);
                };

                request.onupgradeneeded = (event) => {
                    db = event.target.result;

                    // Create nodes store
                    if (!db.objectStoreNames.contains('nodes')) {
                        const nodeStore = db.createObjectStore('nodes', { keyPath: 'id' });
                        nodeStore.createIndex('level', 'level', { unique: false });
                    }

                    // Create connections store
                    if (!db.objectStoreNames.contains('connections')) {
                        db.createObjectStore('connections', { keyPath: 'id', autoIncrement: true });
                    }

                    // Create settings store
                    if (!db.objectStoreNames.contains('settings')) {
                        db.createObjectStore('settings', { keyPath: 'key' });
                    }
                };
            });
        }

        // Save node to database
        async function saveNode(node) {
            const transaction = db.transaction(['nodes'], 'readwrite');
            const store = transaction.objectStore('nodes');
            await store.put(node);
        }

        // Delete node from database
        async function deleteNode(nodeId) {
            const transaction = db.transaction(['nodes'], 'readwrite');
            const store = transaction.objectStore('nodes');
            await store.delete(nodeId);
        }

        // Load all nodes from database
        async function loadNodes() {
            const transaction = db.transaction(['nodes'], 'readonly');
            const store = transaction.objectStore('nodes');
            return new Promise((resolve, reject) => {
                const request = store.getAll();
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        // Save connection to database
        async function saveConnection(connection) {
            const transaction = db.transaction(['connections'], 'readwrite');
            const store = transaction.objectStore('connections');
            await store.put(connection);
        }

        // Delete connection from database
        async function deleteConnection(from, to) {
            const transaction = db.transaction(['connections'], 'readonly');
            const store = transaction.objectStore('connections');
            const request = store.getAll();

            request.onsuccess = async () => {
                const connections = request.result;
                const conn = connections.find(c => c.from === from && c.to === to);
                if (conn) {
                    const deleteTransaction = db.transaction(['connections'], 'readwrite');
                    const deleteStore = deleteTransaction.objectStore('connections');
                    await deleteStore.delete(conn.id);
                }
            };
        }

        // Load all connections from database
        async function loadConnections() {
            const transaction = db.transaction(['connections'], 'readonly');
            const store = transaction.objectStore('connections');
            return new Promise((resolve, reject) => {
                const request = store.getAll();
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        // Save settings
        async function saveSetting(key, value) {
            const transaction = db.transaction(['settings'], 'readwrite');
            const store = transaction.objectStore('settings');
            await store.put({ key, value });
        }

        // Load setting
        async function loadSetting(key) {
            const transaction = db.transaction(['settings'], 'readonly');
            const store = transaction.objectStore('settings');
            return new Promise((resolve, reject) => {
                const request = store.get(key);
                request.onsuccess = () => resolve(request.result ? request.result.value : null);
                request.onerror = () => reject(request.error);
            });
        }

        // Clear entire database
        async function clearDatabase() {
            const transaction = db.transaction(['nodes', 'connections', 'settings'], 'readwrite');
            await transaction.objectStore('nodes').clear();
            await transaction.objectStore('connections').clear();
            await transaction.objectStore('settings').clear();
        }

        // ==================== APP LOGIC ====================
        const canvas = document.getElementById('canvas');
        const canvasInner = document.getElementById('canvas-inner');
        const svg = document.getElementById('connector-svg');
        const modeIndicator = document.getElementById('mode-indicator');

        let nodes = [];
        let connections = [];
        let nodeIdCounter = 0;
        let draggedNode = null;
        let dragOffset = { x: 0, y: 0 };
        let connectMode = false;
        let firstConnectNode = null;
        let lineStyle = 'curved';

        const lineColors = {
            0: 'rgba(0, 240, 255, 0.7)',
            1: 'rgba(255, 0, 229, 0.7)',
            2: 'rgba(255, 213, 0, 0.7)',
            3: 'rgba(0, 255, 136, 0.7)'
        };

        const createNodeElement = (node) => {
            const div = document.createElement('div');
            div.className = `node level-${node.level}`;
            div.dataset.id = node.id;
            div.style.left = `${node.x}px`;
            div.style.top = `${node.y}px`;

            div.innerHTML = `
                <span class="node-text" contenteditable="true">${node.text}</span>
                <div class="node-controls">
                    <button class="icon-btn add-btn" title="Add child">+</button>
                    <button class="icon-btn connect-btn" title="Connect">‚ö°</button>
                    <button class="icon-btn delete-btn" title="Delete">√ó</button>
                </div>
            `;

            const textSpan = div.querySelector('.node-text');

            textSpan.addEventListener('mousedown', (e) => {
                e.stopPropagation();
            });

            textSpan.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    textSpan.blur();
                }
            });

            textSpan.addEventListener('blur', async () => {
                node.text = textSpan.textContent;
                await saveNode(node);
                requestAnimationFrame(() => drawConnections());
            });

            textSpan.addEventListener('input', () => {
                requestAnimationFrame(() => drawConnections());
            });

            div.addEventListener('mousedown', (e) => {
                if (e.target.closest('.icon-btn') || e.target === textSpan) {
                    return;
                }

                draggedNode = node;
                const rect = div.getBoundingClientRect();

                dragOffset.x = e.clientX - rect.left;
                dragOffset.y = e.clientY - rect.top;

                div.classList.add('dragging');
                e.preventDefault();
            });

            div.querySelector('.add-btn').addEventListener('click', async (e) => {
                e.stopPropagation();
                const newNode = {
                    id: nodeIdCounter++,
                    x: node.x + 350,
                    y: node.y + (Math.random() - 0.5) * 100,
                    text: 'New Node',
                    level: (node.level + 1) % 4
                };
                nodes.push(newNode);
                await saveNode(newNode);
                await saveSetting('nodeIdCounter', nodeIdCounter);

                const connection = { from: node.id, to: newNode.id };
                connections.push(connection);
                await saveConnection(connection);

                const elem = createNodeElement(newNode);
                canvasInner.appendChild(elem);
                requestAnimationFrame(() => drawConnections());

                setTimeout(() => {
                    const newTextSpan = elem.querySelector('.node-text');
                    newTextSpan.focus();
                    document.execCommand('selectAll', false, null);
                }, 100);
            });

            div.querySelector('.connect-btn').addEventListener('click', async (e) => {
                e.stopPropagation();
                if (!connectMode) {
                    connectMode = true;
                    firstConnectNode = node;
                    div.classList.add('connecting');
                    modeIndicator.classList.add('active');
                } else {
                    if (firstConnectNode && firstConnectNode.id !== node.id) {
                        const exists = connections.some(c =>
                            (c.from === firstConnectNode.id && c.to === node.id) ||
                            (c.from === node.id && c.to === firstConnectNode.id)
                        );
                        if (!exists) {
                            const connection = { from: firstConnectNode.id, to: node.id };
                            connections.push(connection);
                            await saveConnection(connection);
                            requestAnimationFrame(() => drawConnections());
                        }
                    }
                    document.querySelector('.connecting')?.classList.remove('connecting');
                    connectMode = false;
                    firstConnectNode = null;
                    modeIndicator.classList.remove('active');
                }
            });

            div.querySelector('.delete-btn').addEventListener('click', async (e) => {
                e.stopPropagation();
                nodes = nodes.filter(n => n.id !== node.id);
                await deleteNode(node.id);

                const connectionsToDelete = connections.filter(c => c.from === node.id || c.to === node.id);
                for (const conn of connectionsToDelete) {
                    await deleteConnection(conn.from, conn.to);
                }
                connections = connections.filter(c => c.from !== node.id && c.to !== node.id);

                div.remove();
                requestAnimationFrame(() => drawConnections());
            });

            return div;
        };

        const drawConnections = () => {
            svg.innerHTML = '';

            connections.forEach(conn => {
                const fromNode = nodes.find(n => n.id === conn.from);
                const toNode = nodes.find(n => n.id === conn.to);

                if (fromNode && toNode) {
                    const fromEl = document.querySelector(`[data-id="${fromNode.id}"]`);
                    const toEl = document.querySelector(`[data-id="${toNode.id}"]`);

                    if (fromEl && toEl) {
                        const fromRect = fromEl.getBoundingClientRect();
                        const toRect = toEl.getBoundingClientRect();
                        const canvasRect = canvasInner.getBoundingClientRect();

                        const fromCenterX = fromRect.left + fromRect.width / 2 - canvasRect.left;
                        const fromCenterY = fromRect.top + fromRect.height / 2 - canvasRect.top;
                        const toCenterX = toRect.left + toRect.width / 2 - canvasRect.left;
                        const toCenterY = toRect.top + toRect.height / 2 - canvasRect.top;

                        const dx = toCenterX - fromCenterX;
                        const dy = toCenterY - fromCenterY;

                        let x1, y1, x2, y2;

                        if (Math.abs(dx) > Math.abs(dy)) {
                            if (dx > 0) {
                                x1 = fromRect.right - canvasRect.left;
                                y1 = fromCenterY;
                            } else {
                                x1 = fromRect.left - canvasRect.left;
                                y1 = fromCenterY;
                            }
                        } else {
                            if (dy > 0) {
                                x1 = fromCenterX;
                                y1 = fromRect.bottom - canvasRect.top;
                            } else {
                                x1 = fromCenterX;
                                y1 = fromRect.top - canvasRect.top;
                            }
                        }

                        if (Math.abs(dx) > Math.abs(dy)) {
                            if (dx > 0) {
                                x2 = toRect.left - canvasRect.left;
                                y2 = toCenterY;
                            } else {
                                x2 = toRect.right - canvasRect.left;
                                y2 = toCenterY;
                            }
                        } else {
                            if (dy > 0) {
                                x2 = toCenterX;
                                y2 = toRect.top - canvasRect.top;
                            } else {
                                x2 = toCenterX;
                                y2 = toRect.bottom - canvasRect.top;
                            }
                        }

                        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        let d;

                        const distance = Math.sqrt(dx * dx + dy * dy);
                        const isNearlyHorizontal = Math.abs(dy) < 20 && Math.abs(dx) > 50;
                        const isNearlyVertical = Math.abs(dx) < 20 && Math.abs(dy) > 50;
                        const isNearlyStraight = isNearlyHorizontal || isNearlyVertical;

                        if (lineStyle === 'curved' && !isNearlyStraight) {
                            if (Math.abs(dx) > Math.abs(dy)) {
                                const offsetX = Math.abs(dx) * 0.3;
                                d = `M ${x1} ${y1} C ${x1 + (dx > 0 ? offsetX : -offsetX)} ${y1}, ${x2 - (dx > 0 ? offsetX : -offsetX)} ${y2}, ${x2} ${y2}`;
                            } else {
                                const offsetY = Math.abs(dy) * 0.3;
                                d = `M ${x1} ${y1} C ${x1} ${y1 + (dy > 0 ? offsetY : -offsetY)}, ${x2} ${y2 - (dy > 0 ? offsetY : -offsetY)}, ${x2} ${y2}`;
                            }
                        } else if (lineStyle === 'straight' || isNearlyStraight) {
                            d = `M ${x1} ${y1} L ${x2} ${y2}`;
                        } else if (lineStyle === 'step') {
                            if (Math.abs(dx) > Math.abs(dy)) {
                                const midX = (x1 + x2) / 2;
                                d = `M ${x1} ${y1} L ${midX} ${y1} L ${midX} ${y2} L ${x2} ${y2}`;
                            } else {
                                const midY = (y1 + y2) / 2;
                                d = `M ${x1} ${y1} L ${x1} ${midY} L ${x2} ${midY} L ${x2} ${y2}`;
                            }
                        }

                        path.setAttribute('d', d);
                        path.setAttribute('class', 'connection-line');
                        path.setAttribute('stroke', lineColors[fromNode.level] || lineColors[0]);

                        svg.appendChild(path);
                    }
                }
            });
        };

        let rafId = null;
        document.addEventListener('mousemove', async (e) => {
            if (draggedNode) {
                if (rafId) return;

                rafId = requestAnimationFrame(() => {
                    const canvasRect = canvasInner.getBoundingClientRect();
                    const x = e.clientX - canvasRect.left - dragOffset.x;
                    const y = e.clientY - canvasRect.top - dragOffset.y;

                    draggedNode.x = Math.max(0, x);
                    draggedNode.y = Math.max(0, y);

                    const elem = document.querySelector(`[data-id="${draggedNode.id}"]`);
                    elem.style.left = `${draggedNode.x}px`;
                    elem.style.top = `${draggedNode.y}px`;

                    drawConnections();
                    rafId = null;
                });
            }
        });

        document.addEventListener('mouseup', async () => {
            if (draggedNode) {
                const elem = document.querySelector(`[data-id="${draggedNode.id}"]`);
                elem.classList.remove('dragging');
                await saveNode(draggedNode);
                draggedNode = null;
            }
        });

        document.getElementById('add-node-btn').addEventListener('click', async () => {
            const newNode = {
                id: nodeIdCounter++,
                x: 300 + Math.random() * 200,
                y: 300 + Math.random() * 200,
                text: 'New Node',
                level: 0
            };
            nodes.push(newNode);
            await saveNode(newNode);
            await saveSetting('nodeIdCounter', nodeIdCounter);

            const elem = createNodeElement(newNode);
            canvasInner.appendChild(elem);

            setTimeout(() => {
                const textSpan = elem.querySelector('.node-text');
                textSpan.focus();
                document.execCommand('selectAll', false, null);
            }, 100);
        });

        document.getElementById('connect-mode-btn').addEventListener('click', () => {
            connectMode = !connectMode;
            if (connectMode) {
                modeIndicator.classList.add('active');
            } else {
                modeIndicator.classList.remove('active');
                document.querySelector('.connecting')?.classList.remove('connecting');
                firstConnectNode = null;
            }
        });

        document.querySelectorAll('.line-style-btn').forEach(btn => {
            btn.addEventListener('click', async () => {
                document.querySelectorAll('.line-style-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                lineStyle = btn.dataset.style;
                await saveSetting('lineStyle', lineStyle);
                requestAnimationFrame(() => drawConnections());
            });
        });

        document.getElementById('organize-btn').addEventListener('click', async () => {
            const rootNodes = nodes.filter(node =>
                !connections.some(conn => conn.to === node.id)
            );

            let currentY = 150;

            rootNodes.forEach(rootNode => {
                const tree = buildTree(rootNode.id);
                const treeHeight = layoutTree(tree, 150, currentY, 0);
                currentY += treeHeight + 150;
            });

            nodes.forEach(node => {
                const elem = document.querySelector(`[data-id="${node.id}"]`);
                if (elem) {
                    elem.style.left = `${node.x}px`;
                    elem.style.top = `${node.y}px`;
                }
            });

            requestAnimationFrame(() => {
                nodes.forEach(node => {
                    const elem = document.querySelector(`[data-id="${node.id}"]`);
                    if (elem) {
                        elem.style.transition = 'left 0.5s ease, top 0.5s ease';
                    }
                });

                const startTime = performance.now();
                const animationDuration = 500;

                const animateConnections = (currentTime) => {
                    drawConnections();

                    if (currentTime - startTime < animationDuration) {
                        requestAnimationFrame(animateConnections);
                    } else {
                        nodes.forEach(node => {
                            const elem = document.querySelector(`[data-id="${node.id}"]`);
                            if (elem) {
                                elem.style.transition = '';
                            }
                        });
                    }
                };

                requestAnimationFrame(animateConnections);
            });

            for (const node of nodes) {
                await saveNode(node);
            }
        });

        document.getElementById('clear-db-btn').addEventListener('click', async () => {
            if (confirm('Are you sure you want to delete all nodes and connections? This cannot be undone.')) {
                await clearDatabase();
                nodes = [];
                connections = [];
                nodeIdCounter = 0;
                canvasInner.querySelectorAll('.node').forEach(el => el.remove());
                drawConnections();
                await initializeApp();
            }
        });

        function buildTree(nodeId, visited = new Set()) {
            if (visited.has(nodeId)) return null;
            visited.add(nodeId);

            const node = nodes.find(n => n.id === nodeId);
            if (!node) return null;

            const children = connections
                .filter(conn => conn.from === nodeId)
                .map(conn => buildTree(conn.to, visited))
                .filter(child => child !== null);

            return { node, children };
        }

        function layoutTree(tree, x, y, depth) {
            if (!tree) return 0;

            const horizontalSpacing = 400;
            const verticalSpacing = 80;

            tree.node.x = x;
            tree.node.y = y;

            if (tree.children.length === 0) {
                return verticalSpacing;
            }

            let totalHeight = 0;
            const childHeights = tree.children.map(child => {
                const height = calculateTreeHeight(child, verticalSpacing);
                totalHeight += height;
                return height;
            });

            const childrenStartY = y - (totalHeight - verticalSpacing) / 2;

            let currentChildY = childrenStartY;
            tree.children.forEach((child, index) => {
                const childHeight = layoutTree(
                    child,
                    x + horizontalSpacing,
                    currentChildY + childHeights[index] / 2,
                    depth + 1
                );
                currentChildY += childHeights[index];
            });

            return totalHeight;
        }

        function calculateTreeHeight(tree, spacing) {
            if (!tree || tree.children.length === 0) {
                return spacing;
            }

            const childrenHeight = tree.children.reduce((sum, child) => {
                return sum + calculateTreeHeight(child, spacing);
            }, 0);

            return Math.max(spacing, childrenHeight);
        }

        async function initializeApp() {
            await initDatabase();

            const savedNodes = await loadNodes();
            const savedConnections = await loadConnections();
            const savedLineStyle = await loadSetting('lineStyle');
            const savedCounter = await loadSetting('nodeIdCounter');

            if (savedLineStyle) {
                lineStyle = savedLineStyle;
                document.querySelectorAll('.line-style-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.style === lineStyle);
                });
            }

            if (savedCounter) {
                nodeIdCounter = savedCounter;
            }

            if (savedNodes.length > 0) {
                nodes = savedNodes;
                connections = savedConnections;
                nodeIdCounter = Math.max(...nodes.map(n => n.id)) + 1;
            } else {
                const initNodes = [
                    { id: 0, x: 150, y: 250, text: 'Project: Ares IV Colony', level: 0 },
                    { id: 1, x: 550, y: 180, text: 'PM: Dr. Eva Rostova', level: 1 },
                    { id: 2, x: 950, y: 100, text: 'Senior Developers', level: 2 },
                    { id: 3, x: 950, y: 260, text: 'Junior Developers', level: 2 },
                    { id: 4, x: 1400, y: 50, text: 'Mika Petrova', level: 3 },
                    { id: 5, x: 1400, y: 120, text: 'Dr. Aris Thorne', level: 3 },
                    { id: 6, x: 1400, y: 220, text: 'Leo Kwan', level: 3 },
                    { id: 7, x: 1400, y: 280, text: 'Ria Sharma', level: 3 },
                    { id: 8, x: 1400, y: 340, text: 'Zane Al-Jamil', level: 3 },
                    { id: 9, x: 150, y: 600, text: 'Project: Neptune Deep-Dive', level: 0 },
                    { id: 10, x: 550, y: 600, text: 'PM: Jax Riley', level: 1 },
                    { id: 11, x: 950, y: 540, text: 'Senior Developers', level: 2 },
                    { id: 12, x: 950, y: 660, text: 'Junior Developers', level: 2 },
                    { id: 13, x: 1400, y: 540, text: 'Kenji Tanaka', level: 3 },
                    { id: 14, x: 1400, y: 640, text: 'Sora Kim', level: 3 },
                    { id: 15, x: 1400, y: 700, text: "Finn O'Malley", level: 3 },
                ];

                const initConnections = [
                    { from: 0, to: 1 },
                    { from: 1, to: 2 },
                    { from: 1, to: 3 },
                    { from: 2, to: 4 },
                    { from: 2, to: 5 },
                    { from: 3, to: 6 },
                    { from: 3, to: 7 },
                    { from: 3, to: 8 },
                    { from: 9, to: 10 },
                    { from: 10, to: 11 },
                    { from: 10, to: 12 },
                    { from: 11, to: 13 },
                    { from: 12, to: 14 },
                    { from: 12, to: 15 },
                ];

                nodes = initNodes;
                connections = initConnections;
                nodeIdCounter = initNodes.length;

                for (const node of initNodes) {
                    await saveNode(node);
                }
                for (const conn of initConnections) {
                    await saveConnection(conn);
                }
                await saveSetting('nodeIdCounter', nodeIdCounter);
            }

            nodes.forEach(node => {
                const elem = createNodeElement(node);
                canvasInner.appendChild(elem);
            });

            setTimeout(() => {
                drawConnections();
            }, 50);
        }

        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                requestAnimationFrame(() => drawConnections());
            }, 100);
        });

        initializeApp();
    </script>
</body>

</html>