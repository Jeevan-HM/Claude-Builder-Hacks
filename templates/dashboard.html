<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project Tracker</title>
    <link
        href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700;900&family=Inter:wght@400;600;700&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --cosmic-dark: #0a0e27;
            --cosmic-deep: #1a1d3a;
            --neon-cyan: #00f0ff;
            --neon-magenta: #ff00e5;
            --neon-yellow: #ffd500;
            --neon-green: #00ff88;
            --neon-orange: #ff6b35;
            --neon-purple: #9d4edd;
            --neon-pink: #ff006e;
            --neon-blue: #4361ee;
            --neon-lime: #b5ff37;
            --neon-red: #ff1744;
            --star-white: #ffffff;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1d3a 100%);
            overflow: hidden;
            position: relative;
            height: 100vh;
            color: var(--star-white);
        }

        body::before {
            content: '';
            position: fixed;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            background-image:
                radial-gradient(circle at 20% 30%, rgba(0, 240, 255, 0.03) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(255, 0, 229, 0.03) 0%, transparent 50%),
                radial-gradient(circle at 50% 50%, rgba(255, 213, 0, 0.02) 0%, transparent 50%);
            animation: subtle-glow 10s ease-in-out infinite;
            z-index: -1;
        }

        @keyframes subtle-glow {

            0%,
            100% {
                opacity: 0.5;
            }

            50% {
                opacity: 0.8;
            }
        }

        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            padding: 24px 40px;
            background: rgba(10, 14, 39, 0.7);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid rgba(0, 240, 255, 0.2);
            z-index: 1000;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.8rem;
            font-weight: 900;
            background: linear-gradient(135deg, var(--neon-cyan), var(--neon-magenta));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-transform: uppercase;
            letter-spacing: 0.15rem;
        }

        .controls {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .line-style-selector {
            display: flex;
            gap: 8px;
            padding: 6px 12px;
            background: rgba(0, 240, 255, 0.1);
            border: 1px solid rgba(0, 240, 255, 0.3);
            border-radius: 8px;
            backdrop-filter: blur(10px);
        }

        .line-style-btn {
            padding: 6px 14px;
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: 'Inter', sans-serif;
        }

        .line-style-btn:hover {
            background: rgba(255, 255, 255, 0.05);
            color: var(--star-white);
        }

        .line-style-btn.active {
            background: rgba(0, 240, 255, 0.2);
            border-color: var(--neon-cyan);
            color: var(--neon-cyan);
        }

        .btn {
            padding: 10px 20px;
            background: rgba(0, 240, 255, 0.1);
            border: 1px solid rgba(0, 240, 255, 0.3);
            border-radius: 8px;
            color: var(--neon-cyan);
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: 'Inter', sans-serif;
            backdrop-filter: blur(10px);
        }

        .btn:hover {
            background: rgba(0, 240, 255, 0.2);
            border-color: var(--neon-cyan);
            transform: translateY(-1px);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn.danger {
            background: rgba(255, 0, 229, 0.1);
            border-color: rgba(255, 0, 229, 0.3);
            color: var(--neon-magenta);
        }

        .btn.danger:hover {
            background: rgba(255, 0, 229, 0.2);
            border-color: var(--neon-magenta);
        }

        .canvas {
            position: fixed;
            top: 80px;
            left: 0;
            right: 0;
            bottom: 0;
            overflow: auto;
        }

        .canvas-inner {
            position: relative;
            min-width: 3000px;
            min-height: 2000px;
            width: 100%;
            height: 100%;
        }

        #connector-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .node {
            position: absolute;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            padding: 14px 24px;
            background: rgba(26, 29, 58, 0.8);
            border: 2px solid;
            border-radius: 12px;
            color: var(--star-white);
            font-size: 1rem;
            font-weight: 600;
            cursor: grab;
            user-select: none;
            z-index: 10;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
            backdrop-filter: blur(10px);
            will-change: transform;
        }

        .node:active {
            cursor: grabbing;
        }

        .node:hover {
            transform: translateY(-2px);
            z-index: 100;
            justify-content: flex-start;
        }

        .node.dragging {
            opacity: 0.9;
            z-index: 1000;
            cursor: grabbing !important;
            transform: scale(1.03);
        }

        .node.connecting {
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }
        }

        .node-text {
            flex: 1;
            outline: none;
            min-width: 80px;
            padding: 2px;
            border-radius: 4px;
            transition: background 0.2s ease;
            text-align: center;
        }

        .node:hover .node-text {
            text-align: left;
        }

        .node-text:focus {
            background: rgba(255, 255, 255, 0.05);
        }

        .node-controls {
            display: flex;
            gap: 6px;
            align-items: center;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .node:hover .node-controls {
            opacity: 1;
        }

        .icon-btn {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 1.5px solid;
            background: rgba(10, 14, 39, 0.6);
            font-size: 0.85rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.15s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
            flex-shrink: 0;
        }

        .level-selector {
            position: relative;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            border: 2px solid;
            background: rgba(10, 14, 39, 0.8);
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            font-weight: bold;
            flex-shrink: 0;
        }

        .level-selector:hover {
            transform: scale(1.15);
        }

        .node.level-0 .level-selector {
            border-color: var(--neon-cyan);
            color: var(--neon-cyan);
        }

        .node.level-1 .level-selector {
            border-color: var(--neon-magenta);
            color: var(--neon-magenta);
        }

        .node.level-2 .level-selector {
            border-color: var(--neon-yellow);
            color: var(--neon-yellow);
        }

        .node.level-3 .level-selector {
            border-color: var(--neon-green);
            color: var(--neon-green);
        }

        .node.level-4 .level-selector {
            border-color: var(--neon-orange);
            color: var(--neon-orange);
        }

        .node.level-5 .level-selector {
            border-color: var(--neon-purple);
            color: var(--neon-purple);
        }

        .node.level-6 .level-selector {
            border-color: var(--neon-pink);
            color: var(--neon-pink);
        }

        .node.level-7 .level-selector {
            border-color: var(--neon-blue);
            color: var(--neon-blue);
        }

        .node.level-8 .level-selector {
            border-color: var(--neon-lime);
            color: var(--neon-lime);
        }

        .node.level-9 .level-selector {
            border-color: var(--neon-red);
            color: var(--neon-red);
        }

        .icon-btn:hover {
            transform: scale(1.15);
        }

        .icon-btn:active {
            transform: scale(0.95);
        }

        .add-btn {
            border-color: var(--neon-green);
            color: var(--neon-green);
        }

        .add-btn:hover {
            background: rgba(0, 255, 136, 0.2);
            box-shadow: 0 0 12px rgba(0, 255, 136, 0.4);
        }

        .connect-btn {
            border-color: var(--neon-yellow);
            color: var(--neon-yellow);
        }

        .connect-btn:hover {
            background: rgba(255, 213, 0, 0.2);
            box-shadow: 0 0 12px rgba(255, 213, 0, 0.4);
        }

        .delete-btn {
            border-color: var(--neon-magenta);
            color: var(--neon-magenta);
        }

        .delete-btn:hover {
            background: rgba(255, 0, 229, 0.2);
            box-shadow: 0 0 12px rgba(255, 0, 229, 0.4);
        }

        .node.level-0 {
            border-color: var(--neon-cyan);
            box-shadow: 0 4px 20px rgba(0, 240, 255, 0.25);
        }

        .node.level-0:hover {
            box-shadow: 0 6px 30px rgba(0, 240, 255, 0.4);
        }

        .node.level-1 {
            border-color: var(--neon-magenta);
            box-shadow: 0 4px 20px rgba(255, 0, 229, 0.25);
        }

        .node.level-1:hover {
            box-shadow: 0 6px 30px rgba(255, 0, 229, 0.4);
        }

        .node.level-2 {
            border-color: var(--neon-yellow);
            box-shadow: 0 4px 20px rgba(255, 213, 0, 0.25);
        }

        .node.level-2:hover {
            box-shadow: 0 6px 30px rgba(255, 213, 0, 0.4);
        }

        .node.level-3 {
            border-color: var(--neon-green);
            box-shadow: 0 4px 20px rgba(0, 255, 136, 0.25);
        }

        .node.level-3:hover {
            box-shadow: 0 6px 30px rgba(0, 255, 136, 0.4);
        }

        .node.level-4 {
            border-color: var(--neon-orange);
            box-shadow: 0 4px 20px rgba(255, 107, 53, 0.25);
        }

        .node.level-4:hover {
            box-shadow: 0 6px 30px rgba(255, 107, 53, 0.4);
        }

        .node.level-5 {
            border-color: var(--neon-purple);
            box-shadow: 0 4px 20px rgba(157, 78, 221, 0.25);
        }

        .node.level-5:hover {
            box-shadow: 0 6px 30px rgba(157, 78, 221, 0.4);
        }

        .node.level-6 {
            border-color: var(--neon-pink);
            box-shadow: 0 4px 20px rgba(255, 0, 110, 0.25);
        }

        .node.level-6:hover {
            box-shadow: 0 6px 30px rgba(255, 0, 110, 0.4);
        }

        .node.level-7 {
            border-color: var(--neon-blue);
            box-shadow: 0 4px 20px rgba(67, 97, 238, 0.25);
        }

        .node.level-7:hover {
            box-shadow: 0 6px 30px rgba(67, 97, 238, 0.4);
        }

        .node.level-8 {
            border-color: var(--neon-lime);
            box-shadow: 0 4px 20px rgba(181, 255, 55, 0.25);
        }

        .node.level-8:hover {
            box-shadow: 0 6px 30px rgba(181, 255, 55, 0.4);
        }

        .node.level-9 {
            border-color: var(--neon-red);
            box-shadow: 0 4px 20px rgba(255, 23, 68, 0.25);
        }

        .node.level-9:hover {
            box-shadow: 0 6px 30px rgba(255, 23, 68, 0.4);
        }

        .connection-line {
            stroke-width: 2;
            fill: none;
            opacity: 0.7;
            transition: opacity 0.2s ease;
        }

        .connection-line:hover {
            opacity: 1;
        }

        .mode-indicator {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 28px;
            background: rgba(26, 29, 58, 0.9);
            border: 1px solid var(--neon-yellow);
            border-radius: 20px;
            color: var(--neon-yellow);
            font-weight: 600;
            font-size: 0.9rem;
            z-index: 1000;
            display: none;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 20px rgba(255, 213, 0, 0.3);
        }

        .mode-indicator.active {
            display: block;
            animation: slide-up 0.2s ease;
        }

        @keyframes slide-up {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }

        .status-indicator {
            position: fixed;
            top: 90px;
            right: 40px;
            padding: 8px 16px;
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 8px;
            color: var(--neon-green);
            font-size: 0.85rem;
            font-weight: 600;
            z-index: 1000;
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--neon-green);
            animation: blink 2s ease-in-out infinite;
        }

        @keyframes blink {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.3;
            }
        }

        .canvas::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        .canvas::-webkit-scrollbar-track {
            background: rgba(10, 14, 39, 0.5);
        }

        .canvas::-webkit-scrollbar-thumb {
            background: rgba(0, 240, 255, 0.3);
            border-radius: 4px;
        }

        .canvas::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 240, 255, 0.5);
        }

        .selection-box {
            position: absolute;
            border: 2px dashed var(--neon-cyan);
            background: rgba(0, 240, 255, 0.1);
            pointer-events: none;
            z-index: 1000;
            display: none;
        }

        .node.selected {
            outline: 3px solid var(--neon-cyan);
            outline-offset: 2px;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.3rem;
            }

            .header {
                padding: 20px;
            }

            .btn {
                padding: 8px 16px;
                font-size: 0.85rem;
            }

            .node {
                padding: 12px 18px;
                font-size: 0.9rem;
            }
        }
    </style>
</head>

<body>
    <div class="header">
        <h1>PROJECT COSMOS</h1>
        <div class="controls">
            <div class="line-style-selector">
                <button class="line-style-btn active" data-style="curved">Curved</button>
                <button class="line-style-btn" data-style="straight">Straight</button>
                <button class="line-style-btn" data-style="step">Step</button>
            </div>
            <button class="btn" id="organize-btn">‚ú® Auto Organize</button>
            <button class="btn" id="add-node-btn">+ Add Node</button>
            <button class="btn" id="connect-mode-btn">üîó Connect</button>
            <button class="btn danger" id="clear-db-btn">üóëÔ∏è Clear All</button>
        </div>
    </div>

    <div class="status-indicator">
        <div class="status-dot"></div>
        <span id="status-text">Connected to Flask</span>
    </div>

    <div class="canvas" id="canvas">
        <div class="canvas-inner" id="canvas-inner">
            <svg id="connector-svg"></svg>
            <div class="selection-box" id="selection-box"></div>
        </div>
    </div>

    <div class="mode-indicator" id="mode-indicator">
        Click a node, then click another to connect
    </div>

    <script>
        // ==================== API FUNCTIONS ====================
        const API_BASE = '/api';

        async function apiCall(endpoint, options = {}) {
            try {
                const response = await fetch(`${API_BASE}${endpoint}`, {
                    headers: {
                        'Content-Type': 'application/json',
                        ...options.headers
                    },
                    ...options
                });

                if (!response.ok) {
                    throw new Error(`API Error: ${response.statusText}`);
                }

                return await response.json();
            } catch (error) {
                console.error('API call failed:', error);
                updateStatus('Error: Check console', true);
                throw error;
            }
        }

        async function loadNodesFromDB() {
            return await apiCall('/nodes');
        }

        async function saveNodeToDB(node) {
            return await apiCall('/nodes', {
                method: 'POST',
                body: JSON.stringify(node)
            });
        }

        async function deleteNodeFromDB(nodeId) {
            return await apiCall(`/nodes/${nodeId}`, { method: 'DELETE' });
        }

        async function loadConnectionsFromDB() {
            return await apiCall('/connections');
        }

        async function saveConnectionToDB(connection) {
            return await apiCall('/connections', {
                method: 'POST',
                body: JSON.stringify(connection)
            });
        }

        async function deleteConnectionFromDB(from, to) {
            return await apiCall('/connections/by-nodes', {
                method: 'DELETE',
                body: JSON.stringify({ from, to })
            });
        }

        async function clearAllData() {
            return await apiCall('/clear-all', { method: 'DELETE' });
        }

        async function initializeDatabase() {
            return await apiCall('/init-db', { method: 'POST' });
        }

        function updateStatus(text, isError = false) {
            const statusText = document.getElementById('status-text');
            statusText.textContent = text;
            if (isError) {
                statusText.style.color = 'var(--neon-magenta)';
            } else {
                statusText.style.color = 'var(--neon-green)';
            }
        }

        // ==================== APP LOGIC ====================
        const canvas = document.getElementById('canvas');
        const canvasInner = document.getElementById('canvas-inner');
        const svg = document.getElementById('connector-svg');
        const modeIndicator = document.getElementById('mode-indicator');
        const selectionBox = document.getElementById('selection-box');

        let nodes = [];
        let connections = [];
        let draggedNode = null;
        let dragOffset = { x: 0, y: 0 };
        let connectMode = false;
        let firstConnectNode = null;
        let lineStyle = 'curved';

        // Selection variables
        let isSelecting = false;
        let selectionStart = { x: 0, y: 0 };
        let selectedNodes = new Set();
        let isDraggingSelection = false;
        let selectionDragStart = { x: 0, y: 0 };
        let selectedNodesStartPos = new Map();

        const lineColors = {
            0: 'rgba(0, 240, 255, 0.7)',      // cyan
            1: 'rgba(255, 0, 229, 0.7)',      // magenta
            2: 'rgba(255, 213, 0, 0.7)',      // yellow
            3: 'rgba(0, 255, 136, 0.7)',      // green
            4: 'rgba(255, 107, 53, 0.7)',     // orange
            5: 'rgba(157, 78, 221, 0.7)',     // purple
            6: 'rgba(255, 0, 110, 0.7)',      // pink
            7: 'rgba(67, 97, 238, 0.7)',      // blue
            8: 'rgba(181, 255, 55, 0.7)',     // lime
            9: 'rgba(255, 23, 68, 0.7)'       // red
        };

        const createNodeElement = (node) => {
            const div = document.createElement('div');
            div.className = `node level-${node.level}`;
            div.dataset.id = node.id;
            div.style.left = `${node.x}px`;
            div.style.top = `${node.y}px`;

            div.innerHTML = `
                <span class="node-text" contenteditable="true">${node.text}</span>
                <div class="node-controls">
                    <div class="level-selector" title="Change level">L${node.level}</div>
                    <button class="icon-btn add-btn" title="Add child">+</button>
                    <button class="icon-btn connect-btn" title="Connect">‚ö°</button>
                    <button class="icon-btn delete-btn" title="Delete">√ó</button>
                </div>
            `;

            const textSpan = div.querySelector('.node-text');

            textSpan.addEventListener('mousedown', (e) => {
                e.stopPropagation();
            });

            textSpan.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    textSpan.blur();
                }
            });

            textSpan.addEventListener('blur', async () => {
                node.text = textSpan.textContent;
                await saveNodeToDB(node);
                updateStatus('Saved!');
                setTimeout(() => updateStatus('Connected to Flask'), 2000);
                requestAnimationFrame(() => drawConnections());
            });

            textSpan.addEventListener('input', () => {
                requestAnimationFrame(() => drawConnections());
            });

            div.addEventListener('mousedown', (e) => {
                if (e.target.closest('.icon-btn') || e.target.closest('.level-selector') || e.target === textSpan) {
                    return;
                }

                // If this node is in selection, drag all selected nodes
                if (selectedNodes.has(node.id)) {
                    isDraggingSelection = true;
                    const canvasRect = canvasInner.getBoundingClientRect();
                    selectionDragStart.x = e.clientX - canvasRect.left + canvas.scrollLeft;
                    selectionDragStart.y = e.clientY - canvasRect.top + canvas.scrollTop;

                    // Store starting positions
                    selectedNodesStartPos.clear();
                    selectedNodes.forEach(nodeId => {
                        const n = nodes.find(nd => nd.id === nodeId);
                        if (n) {
                            selectedNodesStartPos.set(nodeId, { x: n.x, y: n.y });
                        }
                    });

                    e.preventDefault();
                    e.stopPropagation();
                    return;
                }

                draggedNode = node;
                const rect = div.getBoundingClientRect();

                dragOffset.x = e.clientX - rect.left;
                dragOffset.y = e.clientY - rect.top;

                div.classList.add('dragging');
                e.preventDefault();
            });

            div.querySelector('.add-btn').addEventListener('click', async (e) => {
                e.stopPropagation();

                const newNode = await saveNodeToDB({
                    x: node.x + 350,
                    y: node.y + (Math.random() - 0.5) * 100,
                    text: 'New Node',
                    level: (node.level + 1) % 10
                });

                nodes.push(newNode);

                const connection = await saveConnectionToDB({
                    from: node.id,
                    to: newNode.id
                });
                connections.push(connection);

                const elem = createNodeElement(newNode);
                canvasInner.appendChild(elem);
                requestAnimationFrame(() => drawConnections());
                updateStatus('Node added!');
                setTimeout(() => updateStatus('Connected to Flask'), 2000);

                setTimeout(() => {
                    const newTextSpan = elem.querySelector('.node-text');
                    newTextSpan.focus();
                    document.execCommand('selectAll', false, null);
                }, 100);
            });

            div.querySelector('.level-selector').addEventListener('click', async (e) => {
                e.stopPropagation();

                // Cycle through levels 0-9
                node.level = (node.level + 1) % 10;

                // Update the node's class and level display
                div.className = `node level-${node.level}`;
                e.target.textContent = `L${node.level}`;

                // Save to database
                await saveNodeToDB(node);

                // Redraw connections with new color
                requestAnimationFrame(() => drawConnections());

                updateStatus('Level changed!');
                setTimeout(() => updateStatus('Connected to Flask'), 2000);
            });

            div.querySelector('.connect-btn').addEventListener('click', async (e) => {
                e.stopPropagation();
                if (!connectMode) {
                    connectMode = true;
                    firstConnectNode = node;
                    div.classList.add('connecting');
                    modeIndicator.classList.add('active');
                } else {
                    if (firstConnectNode && firstConnectNode.id !== node.id) {
                        const exists = connections.some(c =>
                            (c.from === firstConnectNode.id && c.to === node.id) ||
                            (c.from === node.id && c.to === firstConnectNode.id)
                        );
                        if (!exists) {
                            const connection = await saveConnectionToDB({
                                from: firstConnectNode.id,
                                to: node.id
                            });
                            connections.push(connection);
                            requestAnimationFrame(() => drawConnections());
                            updateStatus('Connected!');
                            setTimeout(() => updateStatus('Connected to Flask'), 2000);
                        }
                    }
                    document.querySelector('.connecting')?.classList.remove('connecting');
                    connectMode = false;
                    firstConnectNode = null;
                    modeIndicator.classList.remove('active');
                }
            });

            div.querySelector('.delete-btn').addEventListener('click', async (e) => {
                e.stopPropagation();

                await deleteNodeFromDB(node.id);
                nodes = nodes.filter(n => n.id !== node.id);

                const connectionsToDelete = connections.filter(c => c.from === node.id || c.to === node.id);
                for (const conn of connectionsToDelete) {
                    await deleteConnectionFromDB(conn.from, conn.to);
                }
                connections = connections.filter(c => c.from !== node.id && c.to !== node.id);

                div.remove();
                requestAnimationFrame(() => drawConnections());
                updateStatus('Deleted!');
                setTimeout(() => updateStatus('Connected to Flask'), 2000);
            });

            return div;
        };

        const drawConnections = () => {
            svg.innerHTML = '';

            connections.forEach(conn => {
                const fromNode = nodes.find(n => n.id === conn.from);
                const toNode = nodes.find(n => n.id === conn.to);

                if (fromNode && toNode) {
                    const fromEl = document.querySelector(`[data-id="${fromNode.id}"]`);
                    const toEl = document.querySelector(`[data-id="${toNode.id}"]`);

                    if (fromEl && toEl) {
                        const fromRect = fromEl.getBoundingClientRect();
                        const toRect = toEl.getBoundingClientRect();
                        const canvasRect = canvasInner.getBoundingClientRect();

                        const fromCenterX = fromRect.left + fromRect.width / 2 - canvasRect.left;
                        const fromCenterY = fromRect.top + fromRect.height / 2 - canvasRect.top;
                        const toCenterX = toRect.left + toRect.width / 2 - canvasRect.left;
                        const toCenterY = toRect.top + toRect.height / 2 - canvasRect.top;

                        const dx = toCenterX - fromCenterX;
                        const dy = toCenterY - fromCenterY;

                        let x1, y1, x2, y2;

                        if (Math.abs(dx) > Math.abs(dy)) {
                            if (dx > 0) {
                                x1 = fromRect.right - canvasRect.left;
                                y1 = fromCenterY;
                            } else {
                                x1 = fromRect.left - canvasRect.left;
                                y1 = fromCenterY;
                            }
                        } else {
                            if (dy > 0) {
                                x1 = fromCenterX;
                                y1 = fromRect.bottom - canvasRect.top;
                            } else {
                                x1 = fromCenterX;
                                y1 = fromRect.top - canvasRect.top;
                            }
                        }

                        if (Math.abs(dx) > Math.abs(dy)) {
                            if (dx > 0) {
                                x2 = toRect.left - canvasRect.left;
                                y2 = toCenterY;
                            } else {
                                x2 = toRect.right - canvasRect.left;
                                y2 = toCenterY;
                            }
                        } else {
                            if (dy > 0) {
                                x2 = toCenterX;
                                y2 = toRect.top - canvasRect.top;
                            } else {
                                x2 = toCenterX;
                                y2 = toRect.bottom - canvasRect.top;
                            }
                        }

                        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        let d;

                        const distance = Math.sqrt(dx * dx + dy * dy);
                        const isNearlyHorizontal = Math.abs(dy) < 20 && Math.abs(dx) > 50;
                        const isNearlyVertical = Math.abs(dx) < 20 && Math.abs(dy) > 50;
                        const isNearlyStraight = isNearlyHorizontal || isNearlyVertical;

                        if (lineStyle === 'curved' && !isNearlyStraight) {
                            if (Math.abs(dx) > Math.abs(dy)) {
                                const offsetX = Math.abs(dx) * 0.3;
                                d = `M ${x1} ${y1} C ${x1 + (dx > 0 ? offsetX : -offsetX)} ${y1}, ${x2 - (dx > 0 ? offsetX : -offsetX)} ${y2}, ${x2} ${y2}`;
                            } else {
                                const offsetY = Math.abs(dy) * 0.3;
                                d = `M ${x1} ${y1} C ${x1} ${y1 + (dy > 0 ? offsetY : -offsetY)}, ${x2} ${y2 - (dy > 0 ? offsetY : -offsetY)}, ${x2} ${y2}`;
                            }
                        } else if (lineStyle === 'straight' || isNearlyStraight) {
                            d = `M ${x1} ${y1} L ${x2} ${y2}`;
                        } else if (lineStyle === 'step') {
                            if (Math.abs(dx) > Math.abs(dy)) {
                                const midX = (x1 + x2) / 2;
                                d = `M ${x1} ${y1} L ${midX} ${y1} L ${midX} ${y2} L ${x2} ${y2}`;
                            } else {
                                const midY = (y1 + y2) / 2;
                                d = `M ${x1} ${y1} L ${x1} ${midY} L ${x2} ${midY} L ${x2} ${y2}`;
                            }
                        }

                        path.setAttribute('d', d);
                        path.setAttribute('class', 'connection-line');
                        path.setAttribute('stroke', lineColors[fromNode.level] || lineColors[0]);

                        svg.appendChild(path);
                    }
                }
            });
        };

        // Canvas mousedown for drag-to-select
        canvasInner.addEventListener('mousedown', (e) => {
            // Only start selection if clicking on canvas background (not on a node)
            if (e.target === canvasInner || e.target === svg) {
                const canvasRect = canvasInner.getBoundingClientRect();
                selectionStart.x = e.clientX - canvasRect.left + canvas.scrollLeft;
                selectionStart.y = e.clientY - canvasRect.top + canvas.scrollTop;
                isSelecting = true;

                // Clear previous selection if not holding shift
                if (!e.shiftKey) {
                    selectedNodes.forEach(nodeId => {
                        const elem = document.querySelector(`[data-id="${nodeId}"]`);
                        if (elem) elem.classList.remove('selected');
                    });
                    selectedNodes.clear();
                }

                selectionBox.style.display = 'block';
                selectionBox.style.left = `${selectionStart.x}px`;
                selectionBox.style.top = `${selectionStart.y}px`;
                selectionBox.style.width = '0px';
                selectionBox.style.height = '0px';
            }
        });

        let rafId = null;
        document.addEventListener('mousemove', (e) => {
            if (isSelecting) {
                const canvasRect = canvasInner.getBoundingClientRect();
                const currentX = e.clientX - canvasRect.left + canvas.scrollLeft;
                const currentY = e.clientY - canvasRect.top + canvas.scrollTop;

                const left = Math.min(selectionStart.x, currentX);
                const top = Math.min(selectionStart.y, currentY);
                const width = Math.abs(currentX - selectionStart.x);
                const height = Math.abs(currentY - selectionStart.y);

                selectionBox.style.left = `${left}px`;
                selectionBox.style.top = `${top}px`;
                selectionBox.style.width = `${width}px`;
                selectionBox.style.height = `${height}px`;

                // Check which nodes are in selection
                nodes.forEach(node => {
                    const nodeRight = node.x + 200; // approximate node width
                    const nodeBottom = node.y + 50; // approximate node height

                    const isInSelection = !(
                        node.x > left + width ||
                        nodeRight < left ||
                        node.y > top + height ||
                        nodeBottom < top
                    );

                    const elem = document.querySelector(`[data-id="${node.id}"]`);
                    if (isInSelection) {
                        selectedNodes.add(node.id);
                        if (elem) elem.classList.add('selected');
                    } else if (!e.shiftKey) {
                        selectedNodes.delete(node.id);
                        if (elem) elem.classList.remove('selected');
                    }
                });
            } else if (isDraggingSelection && selectedNodes.size > 0) {
                if (rafId) return;

                rafId = requestAnimationFrame(() => {
                    const canvasRect = canvasInner.getBoundingClientRect();
                    const currentX = e.clientX - canvasRect.left + canvas.scrollLeft;
                    const currentY = e.clientY - canvasRect.top + canvas.scrollTop;

                    const deltaX = currentX - selectionDragStart.x;
                    const deltaY = currentY - selectionDragStart.y;

                    selectedNodes.forEach(nodeId => {
                        const node = nodes.find(n => n.id === nodeId);
                        if (node) {
                            const startPos = selectedNodesStartPos.get(nodeId);
                            node.x = startPos.x + deltaX;
                            node.y = startPos.y + deltaY;

                            const elem = document.querySelector(`[data-id="${nodeId}"]`);
                            if (elem) {
                                elem.style.left = `${node.x}px`;
                                elem.style.top = `${node.y}px`;
                            }
                        }
                    });

                    drawConnections();
                    rafId = null;
                });
            } else if (draggedNode) {
                if (rafId) return;

                rafId = requestAnimationFrame(() => {
                    const canvasRect = canvasInner.getBoundingClientRect();
                    const x = e.clientX - canvasRect.left - dragOffset.x;
                    const y = e.clientY - canvasRect.top - dragOffset.y;

                    draggedNode.x = Math.max(0, x);
                    draggedNode.y = Math.max(0, y);

                    const elem = document.querySelector(`[data-id="${draggedNode.id}"]`);
                    elem.style.left = `${draggedNode.x}px`;
                    elem.style.top = `${draggedNode.y}px`;

                    drawConnections();
                    rafId = null;
                });
            }
        });

        document.addEventListener('mouseup', async () => {
            if (isSelecting) {
                isSelecting = false;
                selectionBox.style.display = 'none';
            } else if (isDraggingSelection) {
                isDraggingSelection = false;

                // Save all moved nodes
                for (const nodeId of selectedNodes) {
                    const node = nodes.find(n => n.id === nodeId);
                    if (node) {
                        await saveNodeToDB(node);
                    }
                }
                updateStatus('Positions saved!');
                setTimeout(() => updateStatus('Connected to Flask'), 2000);
            } else if (draggedNode) {
                const elem = document.querySelector(`[data-id="${draggedNode.id}"]`);
                elem.classList.remove('dragging');
                await saveNodeToDB(draggedNode);
                updateStatus('Position saved!');
                setTimeout(() => updateStatus('Connected to Flask'), 2000);
                draggedNode = null;
            }
        });

        document.getElementById('add-node-btn').addEventListener('click', async () => {
            const newNode = await saveNodeToDB({
                x: 300 + Math.random() * 200,
                y: 300 + Math.random() * 200,
                text: 'New Node',
                level: 0
            });

            nodes.push(newNode);
            const elem = createNodeElement(newNode);
            canvasInner.appendChild(elem);
            updateStatus('Node created!');
            setTimeout(() => updateStatus('Connected to Flask'), 2000);

            setTimeout(() => {
                const textSpan = elem.querySelector('.node-text');
                textSpan.focus();
                document.execCommand('selectAll', false, null);
            }, 100);
        });

        document.getElementById('connect-mode-btn').addEventListener('click', () => {
            connectMode = !connectMode;
            if (connectMode) {
                modeIndicator.classList.add('active');
            } else {
                modeIndicator.classList.remove('active');
                document.querySelector('.connecting')?.classList.remove('connecting');
                firstConnectNode = null;
            }
        });

        document.querySelectorAll('.line-style-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.line-style-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                lineStyle = btn.dataset.style;
                requestAnimationFrame(() => drawConnections());
            });
        });

        document.getElementById('organize-btn').addEventListener('click', async () => {
            const rootNodes = nodes.filter(node =>
                !connections.some(conn => conn.to === node.id)
            );

            let currentY = 150;

            rootNodes.forEach(rootNode => {
                const tree = buildTree(rootNode.id);
                const treeHeight = layoutTree(tree, 250, currentY, 0);
                currentY += treeHeight + 100;
            });

            nodes.forEach(node => {
                const elem = document.querySelector(`[data-id="${node.id}"]`);
                if (elem) {
                    elem.style.left = `${node.x}px`;
                    elem.style.top = `${node.y}px`;
                }
            });

            requestAnimationFrame(() => {
                nodes.forEach(node => {
                    const elem = document.querySelector(`[data-id="${node.id}"]`);
                    if (elem) {
                        elem.style.transition = 'left 0.5s ease, top 0.5s ease';
                    }
                });

                const startTime = performance.now();
                const animationDuration = 500;

                const animateConnections = (currentTime) => {
                    drawConnections();

                    if (currentTime - startTime < animationDuration) {
                        requestAnimationFrame(animateConnections);
                    } else {
                        nodes.forEach(node => {
                            const elem = document.querySelector(`[data-id="${node.id}"]`);
                            if (elem) {
                                elem.style.transition = '';
                            }
                        });
                    }
                };

                requestAnimationFrame(animateConnections);
            });

            for (const node of nodes) {
                await saveNodeToDB(node);
            }
            updateStatus('Layout saved!');
            setTimeout(() => updateStatus('Connected to Flask'), 2000);
        });

        document.getElementById('clear-db-btn').addEventListener('click', async () => {
            if (confirm('Are you sure you want to delete all nodes and connections? This cannot be undone.')) {
                await clearAllData();
                nodes = [];
                connections = [];
                canvasInner.querySelectorAll('.node').forEach(el => el.remove());
                drawConnections();
                updateStatus('Database cleared!');
                setTimeout(() => updateStatus('Connected to Flask'), 2000);

                // Reinitialize with default data
                await initializeApp();
            }
        });

        // Keyboard shortcuts for selection
        document.addEventListener('keydown', (e) => {
            // Ctrl/Cmd + A to select all
            if ((e.ctrlKey || e.metaKey) && e.key === 'a') {
                e.preventDefault();
                nodes.forEach(node => {
                    selectedNodes.add(node.id);
                    const elem = document.querySelector(`[data-id="${node.id}"]`);
                    if (elem) elem.classList.add('selected');
                });
                updateStatus(`${selectedNodes.size} nodes selected`);
                setTimeout(() => updateStatus('Connected to Flask'), 2000);
            }
            // Escape to deselect all
            else if (e.key === 'Escape') {
                selectedNodes.forEach(nodeId => {
                    const elem = document.querySelector(`[data-id="${nodeId}"]`);
                    if (elem) elem.classList.remove('selected');
                });
                selectedNodes.clear();
                updateStatus('Selection cleared');
                setTimeout(() => updateStatus('Connected to Flask'), 2000);
            }
        });

        function buildTree(nodeId, visited = new Set()) {
            if (visited.has(nodeId)) return null;
            visited.add(nodeId);

            const node = nodes.find(n => n.id === nodeId);
            if (!node) return null;

            const children = connections
                .filter(conn => conn.from === nodeId)
                .map(conn => buildTree(conn.to, visited))
                .filter(child => child !== null);

            return { node, children };
        }

        function layoutTree(tree, x, y, depth) {
            if (!tree) return 0;

            const horizontalSpacing = 500;
            const verticalSpacing = 100;

            tree.node.x = x;
            tree.node.y = y;

            if (tree.children.length === 0) {
                return verticalSpacing;
            }

            let totalHeight = 0;
            const childHeights = tree.children.map(child => {
                const height = calculateTreeHeight(child, verticalSpacing);
                totalHeight += height;
                return height;
            });

            const childrenStartY = y - (totalHeight - verticalSpacing) / 2;

            let currentChildY = childrenStartY;
            tree.children.forEach((child, index) => {
                const childHeight = layoutTree(
                    child,
                    x + horizontalSpacing,
                    currentChildY + childHeights[index] / 2,
                    depth + 1
                );
                currentChildY += childHeights[index];
            });

            return totalHeight;
        }

        function calculateTreeHeight(tree, spacing) {
            if (!tree || tree.children.length === 0) {
                return spacing;
            }

            const childrenHeight = tree.children.reduce((sum, child) => {
                return sum + calculateTreeHeight(child, spacing);
            }, 0);

            return Math.max(spacing, childrenHeight);
        }

        async function initializeApp() {
            try {
                updateStatus('Loading...');

                // Initialize database
                await initializeDatabase();

                // Load data from Flask backend
                const loadedNodes = await loadNodesFromDB();
                const loadedConnections = await loadConnectionsFromDB();

                nodes = loadedNodes;
                connections = loadedConnections;

                // Clear existing DOM nodes
                canvasInner.querySelectorAll('.node').forEach(el => el.remove());

                // Create node elements
                nodes.forEach(node => {
                    const elem = createNodeElement(node);
                    canvasInner.appendChild(elem);
                });

                setTimeout(() => {
                    drawConnections();
                    updateStatus('Connected to Flask');
                }, 50);

            } catch (error) {
                console.error('Failed to initialize app:', error);
                updateStatus('Connection failed', true);
            }
        }

        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                requestAnimationFrame(() => drawConnections());
            }, 100);
        });

        // Initialize the app
        initializeApp();
    </script>
</body>

</html>